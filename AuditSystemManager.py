# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AuditSystemManager
                                 A QGIS plugin
 AuditSystemManager - Database audit system with monitoring and rollback
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-22
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Federico Gianoli
        email                : gianoli.federico@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import csv
import json
from datetime import datetime, timedelta

# Constants
DEFAULT_PORT = '5432'
DEFAULT_REFRESH_INTERVAL = 30
MAX_ROWS_DISPLAY = 500
AUDIT_SCHEMA = 'logging'
TRIGGER_NAME = 'Notify_Update_Versioned'

# Common ID fields for record identification
COMMON_ID_FIELDS = ['id', 'gid', 'fid', 'objectid', 'oid', 'pk', '_id']

# Default schemas to monitor
DEFAULT_SCHEMAS = ["total", "office_data", "old_city", "sectorial"]

# Time intervals for filtering
TIME_INTERVALS = {
    "Last hour": "1 hour",
    "Last 6 hours": "6 hours", 
    "Today": "24 hours",
    "Last 3 days": "3 days",
    "Last week": "7 days"
}

# Qt compatibility layer for Qt5/Qt6
try:
    from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer
    from qgis.PyQt.QtGui import QIcon, QFont, QColor
    from qgis.PyQt.QtWidgets import (
        QAction, QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, 
        QPushButton, QLabel, QComboBox, QLineEdit, QTextEdit, QTabWidget, QWidget, 
        QDateTimeEdit, QSpinBox, QCheckBox, QMessageBox, QSplitter, QGroupBox,
        QGridLayout, QProgressBar, QTreeWidget, QTreeWidgetItem, QHeaderView, 
        QFileDialog, QTextBrowser, QListWidget, QListWidgetItem, QApplication, 
        QAbstractItemView, QMenu
    ) 
except ImportError:
    # Fallback for different Qt versions
    try:
        from PyQt6.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer
        from PyQt6.QtGui import QIcon, QFont, QColor, QAction
        from PyQt6.QtWidgets import (
            QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, 
            QPushButton, QLabel, QComboBox, QLineEdit, QTextEdit, QTabWidget, 
            QWidget, QDateTimeEdit, QSpinBox, QCheckBox, QMessageBox, QSplitter, 
            QGroupBox, QGridLayout, QProgressBar, QTreeWidget, QTreeWidgetItem, 
            QHeaderView, QFileDialog, QTextBrowser, QListWidget, QListWidgetItem, 
            QApplication, QAbstractItemView, QMenu
        )
    except ImportError:
        from PyQt5.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer
        from PyQt5.QtGui import QIcon, QFont, QColor
        from PyQt5.QtWidgets import (
            QAction, QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, 
            QPushButton, QLabel, QComboBox, QLineEdit, QTextEdit, QTabWidget, QWidget, 
            QDateTimeEdit, QSpinBox, QCheckBox, QMessageBox, QSplitter, QGroupBox,
            QGridLayout, QProgressBar, QTreeWidget, QTreeWidgetItem, QHeaderView, 
            QFileDialog, QTextBrowser, QListWidget, QListWidgetItem, QApplication, 
            QAbstractItemView, QMenu
        )

from qgis.core import QgsProject, QgsDataSourceUri, QgsVectorLayer

# PostgreSQL dependency check
try:
    import psycopg2
    PSYCOPG2_AVAILABLE = True
except ImportError:
    PSYCOPG2_AVAILABLE = False


# =====================================================
# UTILITY FUNCTIONS
# =====================================================

def format_timestamp(timestamp):
    """Format timestamp for display"""
    if timestamp:
        return timestamp.strftime("%d/%m/%Y %H:%M:%S")
    return ""

def safe_get_text(item):
    """Safely get text from QTableWidgetItem"""
    return item.text() if item else ""

def show_error_message(parent, title, message):
    """Show standardized error message"""
    QMessageBox.critical(parent, title, message)

def show_info_message(parent, title, message):
    """Show standardized info message"""
    QMessageBox.information(parent, title, message)

def show_question(parent, title, message):
    """Show standardized question dialog"""
    return QMessageBox.question(parent, title, message, 
                               QMessageBox.Yes | QMessageBox.No)


# =====================================================
# DOCUMENTATION DIALOG CLASS
# =====================================================

class HelpDialog(QDialog):
    """Help and Documentation Dialog for Audit System Manager"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUI()
        
    def setupUI(self):
        """Setup the help dialog interface"""
        self.setWindowTitle("Audit System Manager - Documentation")
        self.setMinimumSize(900, 700)
        self.setModal(False)
        
        layout = QVBoxLayout()
        
        # Navigation buttons
        nav_layout = self._create_navigation_layout()
        
        # Content browser
        self.content_browser = QTextBrowser()
        self.content_browser.setOpenExternalLinks(False)
        
        # Set font for better readability
        font = QFont("Consolas", 10)
        self.content_browser.setFont(font)
        
        layout.addLayout(nav_layout)
        layout.addWidget(self.content_browser)
        
        self.setLayout(layout)
        
        # Show overview by default
        self.show_section("overview")
        
    def _create_navigation_layout(self):
        """Create navigation button layout"""
        nav_layout = QHBoxLayout()
        
        # Define navigation buttons
        nav_buttons = [
            ("Overview", "overview"),
            ("Monitoring", "monitoring"),
            ("Versioning", "versioning"),
            ("Rollback", "rollback"),
            ("Configuration", "configuration"),
            ("Examples", "examples"),
            ("SQL Reference", "sql")
        ]
        
        self.nav_buttons = {}
        
        for text, section in nav_buttons:
            btn = QPushButton(text)
            btn.clicked.connect(lambda checked, s=section: self.show_section(s))
            nav_layout.addWidget(btn)
            self.nav_buttons[section] = btn
        
        nav_layout.addStretch()
        return nav_layout
        
    def show_section(self, section):
        """Display the selected documentation section"""
        content = self.get_documentation_content(section)
        self.content_browser.setHtml(content)
        
        # Highlight active button
        for btn in self.nav_buttons.values():
            btn.setStyleSheet("")
        
        if section in self.nav_buttons:
            self.nav_buttons[section].setStyleSheet("background-color: #e3f2fd;")
            
    def get_documentation_content(self, section):
        """Load documentation from separate HTML files"""
        try:
            plugin_dir = os.path.dirname(__file__)
            help_dir = os.path.join(plugin_dir, 'help_docs')
            file_path = os.path.join(help_dir, f'{section}.html')
            
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    return f.read()
            else:
                return f"<h1>Documentation for {section}</h1><p>File not found: {file_path}</p>"
                
        except Exception as e:
            return f"<h1>Error loading documentation</h1><p>Error: {str(e)}</p>"


# =====================================================
# DATABASE CONFIGURATION DIALOG
# =====================================================

class DatabaseConfigDialog(QDialog):
    """Dialog for database connection configuration"""
    
    def __init__(self, manager, parent=None):
        super().__init__(parent)
        self.manager = manager
        self.setupUI()
        self.load_current_settings()
        
    def setupUI(self):
        """Setup the configuration dialog interface"""
        self.setWindowTitle("Database Configuration")
        self.setMinimumSize(400, 300)
        self.setModal(True)
        
        layout = QVBoxLayout()
        
        # Connection settings group
        conn_group = self._create_connection_group()
        
        # Security note
        security_note = QLabel(
            "Note: Connection settings are saved locally in QGIS settings. "
            "Use 'Clear Saved' to remove stored credentials."
        )
        security_note.setStyleSheet("color: #666; font-size: 9px; font-style: italic;")
        security_note.setWordWrap(True)
        
        # Connection status
        self.status_label = QLabel("Enter connection details above")
        self.status_label.setStyleSheet("color: gray; font-style: italic;")
        
        # Buttons
        button_layout = self._create_button_layout()
        
        # Layout assembly
        layout.addWidget(conn_group)
        layout.addWidget(security_note)
        layout.addWidget(self.status_label)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
        
    def _create_connection_group(self):
        """Create connection settings group"""
        conn_group = QGroupBox("Database Connection")
        conn_layout = QGridLayout()
        
        # Connection fields
        fields = [
            ("Host:", "host_edit", "e.g., localhost or 192.168.1.100"),
            ("Port:", "port_edit", DEFAULT_PORT),
            ("Database:", "database_edit", "Database name"),
            ("Username:", "user_edit", "Database username"),
            ("Password:", "password_edit", "Database password")
        ]
        
        for i, (label, attr_name, placeholder) in enumerate(fields):
            row = i // 2 if i < 2 else i - 1
            col = (i % 2) * 2 if i < 2 else 0
            col_span = 1 if i < 2 else 3
            
            conn_layout.addWidget(QLabel(label), row, col)
            
            edit = QLineEdit()
            edit.setPlaceholderText(placeholder)
            
            if attr_name == "password_edit":
                edit.setEchoMode(QLineEdit.Password)
                
            setattr(self, attr_name, edit)
            conn_layout.addWidget(edit, row, col + 1, 1, col_span)
        
        conn_group.setLayout(conn_layout)
        return conn_group
        
    def _create_button_layout(self):
        """Create button layout"""
        button_layout = QHBoxLayout()
        
        # Buttons configuration
        buttons = [
            ("Test Connection", self.test_connection),
            ("Clear Saved", self.clear_saved_settings),
            ("Cancel", self.reject),
            ("Save & Connect", self.save_and_connect)
        ]
        
        for text, handler in buttons:
            btn = QPushButton(text)
            btn.clicked.connect(handler)
            
            if text == "Save & Connect":
                self.save_btn = btn
            elif text == "Test Connection":
                self.test_btn = btn
            elif text == "Clear Saved":
                self.clear_btn = btn
            elif text == "Cancel":
                self.cancel_btn = btn
                
            button_layout.addWidget(btn)
            
            if text == "Clear Saved":
                button_layout.addStretch()
        
        return button_layout
        
    def load_current_settings(self):
        """Load current database settings into form"""
        params = self.manager.db_params
        self.host_edit.setText(params.get('host', ''))
        self.port_edit.setText(params.get('port', DEFAULT_PORT))
        self.database_edit.setText(params.get('database', ''))
        self.user_edit.setText(params.get('user', ''))
        self.password_edit.setText(params.get('password', ''))
        
    def get_connection_params(self):
        """Get connection parameters from form"""
        return {
            'host': self.host_edit.text().strip(),
            'port': self.port_edit.text().strip() or DEFAULT_PORT,
            'database': self.database_edit.text().strip(),
            'user': self.user_edit.text().strip(),
            'password': self.password_edit.text()
        }
        
    def test_connection(self):
        """Test database connection"""
        params = self.get_connection_params()
        
        # Validate required fields
        required_fields = ['host', 'database', 'user']
        if not all(params.get(field) for field in required_fields):
            self._set_status("Please fill in all required fields", "red")
            return
            
        try:
            if not PSYCOPG2_AVAILABLE:
                raise Exception("psycopg2 library not available. Please install it.")
                
            # Test connection
            test_conn = psycopg2.connect(
                host=params['host'],
                port=params['port'],
                database=params['database'],
                user=params['user'],
                password=params['password']
            )
            
            # Test query
            cursor = test_conn.cursor()
            cursor.execute("SELECT version();")
            cursor.close()
            test_conn.close()
            
            self._set_status("Connection successful!", "green")
            self.save_btn.setEnabled(True)
            
        except Exception as e:
            self._set_status(f"Connection failed: {str(e)}", "red")
            self.save_btn.setEnabled(False)
            
    def _set_status(self, message, color):
        """Set status message with color"""
        self.status_label.setText(message)
        style = f"color: {color};"
        if color == "green":
            style += " font-weight: bold;"
        self.status_label.setStyleSheet(style)
            
    def clear_saved_settings(self):
        """Clear saved database settings"""
        reply = show_question(self, "Clear Settings", 
            "Are you sure you want to clear saved database settings?")
            
        if reply == QMessageBox.Yes:
            self.manager.clear_db_settings()
            # Clear form fields
            self.host_edit.clear()
            self.port_edit.setText(DEFAULT_PORT)
            self.database_edit.clear()
            self.user_edit.clear()
            self.password_edit.clear()
            
            self._set_status("Saved settings cleared", "orange")
            show_info_message(self, "Settings Cleared", "Database settings have been cleared.")
            
    def save_and_connect(self):
        """Save connection settings and close dialog"""
        params = self.get_connection_params()
        
        # Validate required fields
        required_fields = ['host', 'database', 'user']
        if not all(params.get(field) for field in required_fields):
            QMessageBox.warning(self, "Incomplete", "Please fill in all required fields")
            return
            
        # Save settings
        self.manager.db_params = params
        self.manager.save_db_settings(params)
        
        self.accept()


# =====================================================
# AUDIT SYSTEM SETUP DIALOG
# =====================================================

class AuditSetupDialog(QDialog):
    """Dialog for setting up and configuring the audit system"""
    
    def __init__(self, db_connection, parent=None):
        super().__init__(parent)
        self.db_connection = db_connection
        self.setupUI()
        self.load_database_info()
        
    def setupUI(self):
        """Setup the audit configuration interface"""
        self.setWindowTitle("Audit System Setup & Configuration")
        self.setMinimumSize(800, 600)
        
        layout = QVBoxLayout()
        
        # Tab widget for different setup steps
        self.tab_widget = QTabWidget()
        
        # Setup tabs
        self.setup_installation_tab()
        self.setup_selection_tab()
        self.setup_status_tab()
        
        layout.addWidget(self.tab_widget)
        
        # Bottom buttons
        button_layout = QHBoxLayout()
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.accept)
        
        button_layout.addStretch()
        button_layout.addWidget(self.close_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def setup_installation_tab(self):
        """Setup system installation tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Installation status
        status_group = QGroupBox("System Status")
        status_layout = QVBoxLayout()
        
        self.installation_status = QLabel("Checking system status...")
        self.installation_status.setStyleSheet("font-weight: bold; font-size: 12px;")
        status_layout.addWidget(self.installation_status)
        
        status_group.setLayout(status_layout)
        
        # Installation controls
        install_group = self._create_installation_group()
        
        # Installation log
        log_group = QGroupBox("Installation Log")
        log_layout = QVBoxLayout()
        
        self.install_log = QTextEdit()
        self.install_log.setMaximumHeight(200)
        self.install_log.setReadOnly(True)
        log_layout.addWidget(self.install_log)
        
        log_group.setLayout(log_layout)
        
        layout.addWidget(status_group)
        layout.addWidget(install_group)
        layout.addWidget(log_group)
        layout.addStretch()
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "System Installation")
        
    def _create_installation_group(self):
        """Create installation controls group"""
        install_group = QGroupBox("Install Audit System")
        install_layout = QVBoxLayout()
        
        install_info = QLabel("""
        This will install the complete audit system infrastructure:
        - logging schema with audit tables
        - Trigger functions for change tracking
        - Versioning and rollback functions
        - Views for easy data access
        
        Note: Requires CREATE privileges on the database
        """)
        install_layout.addWidget(install_info)
        
        install_buttons = QHBoxLayout()
        self.install_btn = QPushButton("Install Audit System")
        self.install_btn.clicked.connect(self.install_audit_system)
        
        self.reinstall_btn = QPushButton("Reinstall/Update System")
        self.reinstall_btn.clicked.connect(self.reinstall_audit_system)
        
        install_buttons.addWidget(self.install_btn)
        install_buttons.addWidget(self.reinstall_btn)
        install_buttons.addStretch()
        
        install_layout.addLayout(install_buttons)
        install_group.setLayout(install_layout)
        
        return install_group
        
    def setup_selection_tab(self):
        """Setup schema and table selection tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Schema selection
        schema_group = self._create_schema_selection_group()
        
        # Apply configuration
        apply_group = self._create_apply_configuration_group()
        
        layout.addWidget(schema_group)
        layout.addWidget(apply_group)
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Configure Monitoring")
        
    def _create_schema_selection_group(self):
        """Create schema selection group"""
        schema_group = QGroupBox("Schema & Table Selection")
        schema_layout = QVBoxLayout()
        
        # Available schemas layout
        schemas_layout = QHBoxLayout()
        
        # Left side - Available schemas
        left_layout = QVBoxLayout()
        left_layout.addWidget(QLabel("Available Schemas:"))
        
        self.available_schemas = QListWidget()
        self.available_schemas.setMaximumHeight(150)
        left_layout.addWidget(self.available_schemas)
        
        # Schema buttons
        schema_btn_layout = QHBoxLayout()
        self.add_schema_btn = QPushButton("Add Schema →")
        self.add_schema_btn.clicked.connect(self.add_selected_schema)
        
        self.remove_schema_btn = QPushButton("← Remove Schema")
        self.remove_schema_btn.clicked.connect(self.remove_selected_schema)
        
        schema_btn_layout.addWidget(self.add_schema_btn)
        schema_btn_layout.addWidget(self.remove_schema_btn)
        
        # Right side - Monitored schemas
        right_layout = QVBoxLayout()
        right_layout.addWidget(QLabel("Monitored Schemas:"))
        
        self.monitored_schemas = QListWidget()
        self.monitored_schemas.setMaximumHeight(150)
        right_layout.addWidget(self.monitored_schemas)
        
        schemas_layout.addLayout(left_layout)
        schemas_layout.addLayout(right_layout)
        
        schema_layout.addLayout(schemas_layout)
        schema_layout.addLayout(schema_btn_layout)
        
        # Table-specific controls
        table_specific_layout = self._create_table_specific_layout()
        schema_layout.addLayout(table_specific_layout)
        
        schema_group.setLayout(schema_layout)
        return schema_group
        
    def _create_table_specific_layout(self):
        """Create table-specific controls layout"""
        table_specific_layout = QHBoxLayout()
        
        table_specific_layout.addWidget(QLabel("Schema:"))
        self.table_schema_combo = QComboBox()
        table_specific_layout.addWidget(self.table_schema_combo)
        
        table_specific_layout.addWidget(QLabel("Table:"))
        self.table_name_combo = QComboBox()
        table_specific_layout.addWidget(self.table_name_combo)
        
        self.add_table_btn = QPushButton("Add Single Table")
        self.add_table_btn.clicked.connect(self.add_single_table)
        table_specific_layout.addWidget(self.add_table_btn)
        
        table_specific_layout.addStretch()
        return table_specific_layout
        
    def _create_apply_configuration_group(self):
        """Create apply configuration group"""
        apply_group = QGroupBox("Apply Configuration")
        apply_layout = QVBoxLayout()
        
        apply_info = QLabel("This will create triggers on selected schemas/tables to enable monitoring.")
        apply_layout.addWidget(apply_info)
        
        apply_buttons = QHBoxLayout()
        
        self.preview_btn = QPushButton("Preview Changes")
        self.preview_btn.clicked.connect(self.preview_configuration)
        
        self.apply_btn = QPushButton("Apply Configuration")
        self.apply_btn.clicked.connect(self.apply_configuration)
        
        apply_buttons.addWidget(self.preview_btn)
        apply_buttons.addWidget(self.apply_btn)
        apply_buttons.addStretch()
        
        apply_layout.addLayout(apply_buttons)
        
        # Configuration log
        self.config_log = QTextEdit()
        self.config_log.setMaximumHeight(150)
        self.config_log.setReadOnly(True)
        apply_layout.addWidget(self.config_log)
        
        apply_group.setLayout(apply_layout)
        return apply_group
        
    def setup_status_tab(self):
        """Setup status and verification tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Current status
        status_group = QGroupBox("Current Monitoring Status")
        status_layout = QVBoxLayout()
        
        refresh_layout = QHBoxLayout()
        self.refresh_status_btn = QPushButton("Refresh Status")
        self.refresh_status_btn.clicked.connect(self.refresh_status)
        refresh_layout.addWidget(self.refresh_status_btn)
        refresh_layout.addStretch()
        
        status_layout.addLayout(refresh_layout)
        
        # Status table
        self.status_table = QTableWidget()
        self.status_table.setColumnCount(3)
        self.status_table.setHorizontalHeaderLabels(["Schema", "Tables Monitored", "Status"])
        self.status_table.horizontalHeader().setStretchLastSection(True)
        status_layout.addWidget(self.status_table)
        
        status_group.setLayout(status_layout)
        
        # System information
        info_group = QGroupBox("System Information")
        info_layout = QVBoxLayout()
        
        self.system_info = QTextEdit()
        self.system_info.setMaximumHeight(200)
        self.system_info.setReadOnly(True)
        info_layout.addWidget(self.system_info)
        
        info_group.setLayout(info_layout)
        
        layout.addWidget(status_group)
        layout.addWidget(info_group)
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Status & Verification")
        
    def load_database_info(self):
        """Load database information and check system status"""
        try:
            self.check_system_status()
            self.load_available_schemas()
            self.load_monitored_schemas()
            self.refresh_status()
            
        except Exception as e:
            show_error_message(self, "Error", f"Failed to load database information: {str(e)}")
            
    def check_system_status(self):
        """Check if audit system is installed"""
        try:
            cursor = self.db_connection.cursor()
            
            # Check if logging schema exists
            cursor.execute("""
                SELECT schema_name FROM information_schema.schemata 
                WHERE schema_name = %s
            """, (AUDIT_SCHEMA,))
            
            schema_exists = cursor.fetchone() is not None
            
            if schema_exists:
                # Check if main functions exist
                cursor.execute("""
                    SELECT COUNT(*) FROM information_schema.routines
                    WHERE routine_schema = %s
                    AND routine_name IN ('notify_with_versioning', 'rollback_record_to_version')
                """, (AUDIT_SCHEMA,))
                
                function_count = cursor.fetchone()[0]
                
                if function_count >= 2:
                    self._set_installation_status("Audit system is installed and ready", "green", True)
                else:
                    self._set_installation_status("Audit system partially installed", "orange", False)
            else:
                self._set_installation_status("Audit system not installed", "red", False)
                
            cursor.close()
            
        except Exception as e:
            self._set_installation_status(f"Error checking system: {str(e)}", "red", False)
            
    def _set_installation_status(self, message, color, installed):
        """Set installation status message"""
        self.installation_status.setText(message)
        self.installation_status.setStyleSheet(f"color: {color}; font-weight: bold;")
        
        if installed:
            self.install_btn.setText("System Already Installed")
            self.install_btn.setEnabled(False)
        
    def load_available_schemas(self):
        """Load available database schemas"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                SELECT schema_name 
                FROM information_schema.schemata 
                WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast', %s)
                AND schema_name NOT LIKE 'pg_temp_%%'
                ORDER BY schema_name
            """, (AUDIT_SCHEMA,))
            
            schemas = [row[0] for row in cursor.fetchall()]
            
            self.available_schemas.clear()
            for schema in schemas:
                self.available_schemas.addItem(schema)
                
            # Populate table schema combo
            self.table_schema_combo.clear()
            self.table_schema_combo.addItems(schemas)
            
            # Connect schema combo to table loading
            try:
                self.table_schema_combo.currentTextChanged.disconnect()
            except:
                pass  # No previous connection
            self.table_schema_combo.currentTextChanged.connect(self.load_tables_for_schema)
            
            # Load tables for first schema
            if schemas:
                self.load_tables_for_schema(schemas[0])
                
            cursor.close()
            
        except Exception as e:
            show_error_message(self, "Error", f"Failed to load schemas: {str(e)}")
            
    def load_tables_for_schema(self, schema_name):
        """Load tables for selected schema"""
        if not schema_name:
            return
            
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = %s 
                AND table_type = 'BASE TABLE'
                ORDER BY table_name
            """, (schema_name,))
            
            tables = [row[0] for row in cursor.fetchall()]
            
            self.table_name_combo.clear()
            self.table_name_combo.addItems(tables)
            
            cursor.close()
            
        except Exception as e:
            print(f"Error loading tables for schema {schema_name}: {e}")
            
    def load_monitored_schemas(self):
        """Load currently monitored schemas"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("""
                SELECT DISTINCT n.nspname
                FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                WHERE t.tgname = %s
                ORDER BY n.nspname
            """, (TRIGGER_NAME,))
            
            schemas = [row[0] for row in cursor.fetchall()]
            
            self.monitored_schemas.clear()
            for schema in schemas:
                self.monitored_schemas.addItem(schema)
                
            cursor.close()
            
        except Exception:
            # Might fail if system not installed yet
            pass
            
    def install_audit_system(self):
        """Install the complete audit system"""
        try:
            self.install_log.clear()
            self.install_log.append("Installing audit system...")
            
            # Get the complete SQL script
            sql_script = self.get_audit_system_sql()
            
            cursor = self.db_connection.cursor()
            
            # Execute the installation script
            self.install_log.append("Executing installation script...")
            cursor.execute(sql_script)
            
            self.db_connection.commit()
            cursor.close()
            
            self.install_log.append("Audit system installed successfully!")
            self.check_system_status()
            
            show_info_message(self, "Success", "Audit system installed successfully!")
            
        except Exception as e:
            self.db_connection.rollback()
            self.install_log.append(f"Installation failed: {str(e)}")
            show_error_message(self, "Installation Error", 
                             f"Failed to install audit system:\n{str(e)}")
            
    def reinstall_audit_system(self):
        """Reinstall/update the audit system"""
        reply = show_question(
            self,
            "Confirm Reinstallation",
            "This will reinstall the audit system. Existing audit data will be preserved.\n\nContinue?"
        )
        
        if reply == QMessageBox.Yes:
            self.install_audit_system()
            
    def add_selected_schema(self):
        """Add selected schema to monitoring"""
        current_item = self.available_schemas.currentItem()
        if current_item:
            schema_name = current_item.text()
            
            # Check if already monitored
            for i in range(self.monitored_schemas.count()):
                if self.monitored_schemas.item(i).text() == schema_name:
                    show_info_message(self, "Info", 
                                    f"Schema '{schema_name}' is already monitored")
                    return
                    
            self.monitored_schemas.addItem(schema_name)
            
    def remove_selected_schema(self):
        """Remove selected schema from monitoring"""
        current_item = self.monitored_schemas.currentItem()
        if current_item:
            row = self.monitored_schemas.row(current_item)
            self.monitored_schemas.takeItem(row)
            
    def add_single_table(self):
        """Add monitoring to a single table"""
        schema = self.table_schema_combo.currentText()
        table = self.table_name_combo.currentText()
        
        if schema and table:
            show_info_message(self, "Info", 
                            f"Table {schema}.{table} will be added to monitoring when configuration is applied")
        else:
            QMessageBox.warning(self, "Warning", "Please select both schema and table")
            
    def preview_configuration(self):
        """Preview the configuration changes that will be applied"""
        try:
            sql_commands = self.generate_configuration_sql()
            
            preview_dialog = QDialog(self)
            preview_dialog.setWindowTitle("Preview Configuration Changes")
            preview_dialog.setMinimumSize(600, 400)
            
            layout = QVBoxLayout()
            
            layout.addWidget(QLabel("The following SQL commands will be executed:"))
            
            preview_text = QTextEdit()
            preview_text.setPlainText(sql_commands)
            preview_text.setReadOnly(True)
            layout.addWidget(preview_text)
            
            button_layout = QHBoxLayout()
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(preview_dialog.accept)
            button_layout.addStretch()
            button_layout.addWidget(close_btn)
            
            layout.addLayout(button_layout)
            preview_dialog.setLayout(layout)
            
            preview_dialog.exec_()
            
        except Exception as e:
            show_error_message(self, "Error", f"Failed to generate preview: {str(e)}")
            
    def apply_configuration(self):
        """Apply the monitoring configuration"""
        try:
            self.config_log.clear()
            self.config_log.append("Applying monitoring configuration...")
            
            sql_commands = self.generate_configuration_sql()
            
            cursor = self.db_connection.cursor()
            cursor.execute(sql_commands)
            self.db_connection.commit()
            cursor.close()
            
            self.config_log.append("Configuration applied successfully!")
            self.refresh_status()
            
            show_info_message(self, "Success", "Monitoring configuration applied successfully!")
            
        except Exception as e:
            self.db_connection.rollback()
            self.config_log.append(f"Configuration failed: {str(e)}")
            show_error_message(self, "Configuration Error", 
                             f"Failed to apply configuration:\n{str(e)}")
            
    def generate_configuration_sql(self):
        """Generate SQL commands for the current configuration"""
        sql_parts = []
        
        # Apply to selected schemas
        for i in range(self.monitored_schemas.count()):
            schema_name = self.monitored_schemas.item(i).text()
            
            schema_sql = f"""
-- Apply monitoring to {schema_name} schema
DO $$
DECLARE
    t text;
BEGIN
    FOR t IN
        SELECT table_name FROM information_schema.tables
        WHERE table_schema='{schema_name}' AND table_type = 'BASE TABLE'
    LOOP
        EXECUTE format('DROP TRIGGER IF EXISTS "{TRIGGER_NAME}" ON {schema_name}.%I', t);
        EXECUTE format('CREATE TRIGGER "{TRIGGER_NAME}"
                        AFTER INSERT OR DELETE OR UPDATE ON {schema_name}.%I
                        FOR EACH ROW EXECUTE FUNCTION {AUDIT_SCHEMA}.notify_with_versioning()', t);
    END LOOP;
    RAISE NOTICE 'COMPLETE: {schema_name} schema monitoring enabled';
END;
$$ LANGUAGE plpgsql;
"""
            sql_parts.append(schema_sql)
            
        return "\n".join(sql_parts)
        
    def refresh_status(self):
        """Refresh the monitoring status display"""
        try:
            cursor = self.db_connection.cursor()
            
            # Get monitoring status by schema
            cursor.execute("""
                SELECT 
                    n.nspname as schema_name,
                    COUNT(DISTINCT c.relname) as monitored_tables
                FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                WHERE t.tgname = %s
                GROUP BY n.nspname
                ORDER BY n.nspname
            """, (TRIGGER_NAME,))
            
            status_data = cursor.fetchall()
            
            self.status_table.setRowCount(len(status_data))
            for i, (schema, table_count) in enumerate(status_data):
                self.status_table.setItem(i, 0, QTableWidgetItem(schema))
                self.status_table.setItem(i, 1, QTableWidgetItem(str(table_count)))
                self.status_table.setItem(i, 2, QTableWidgetItem("Active"))
                
            # Update system information
            self._update_system_information(cursor)
            cursor.close()
            
        except Exception as e:
            self.system_info.setPlainText(f"Error loading system information: {e}")
            
    def _update_system_information(self, cursor):
        """Update system information display"""
        try:
            cursor.execute("SELECT version()")
            pg_version = cursor.fetchone()[0]
            
            cursor.execute(f"""
                SELECT COUNT(*) FROM {AUDIT_SCHEMA}.t_history
                WHERE tstamp >= CURRENT_DATE
            """)
            
            today_changes = cursor.fetchone()[0] if cursor.rowcount > 0 else 0
            
            cursor.execute(f"""
                SELECT pg_size_pretty(pg_total_relation_size('{AUDIT_SCHEMA}.t_history'))
            """)
            
            log_size = cursor.fetchone()[0] if cursor.rowcount > 0 else "N/A"
            
            info_text = f"""PostgreSQL Version: {pg_version[:50]}...

Monitoring Status:
- Schemas monitored: {len(self.status_table.rowCount()) if hasattr(self, 'status_table') else 0}
- Changes today: {today_changes}
- Audit log size: {log_size}

System Compatibility:
- Plugin Version: 1.0.0
- Qt Version: Compatible (Auto-detected Qt5/Qt6)
- PostgreSQL: Version {pg_version.split()[1]} supported

Last updated: {format_timestamp(datetime.now())}
            """
            
            self.system_info.setPlainText(info_text)
            
        except Exception as e:
            print(f"Error updating system information: {e}")
            
    def get_audit_system_sql(self):
        """Return the complete audit system SQL script"""
        return f"""
-- =====================================================
-- COMPLETE AUDIT SYSTEM FOR POSTGRESQL
-- Monitoring, Versioning & Rollback System
-- =====================================================

-- Create logging schema for audit tables and functions
CREATE SCHEMA IF NOT EXISTS {AUDIT_SCHEMA};

-- Base audit table - stores all database changes
CREATE TABLE IF NOT EXISTS {AUDIT_SCHEMA}.t_history (
    id                 serial PRIMARY KEY,
    tstamp             timestamp       DEFAULT now(),
    epoc               float,
    schemaname         text,
    tabname            text,
    operation          text,
    who                text            DEFAULT current_user,
    new_val            json,
    old_val            json,
    sync               json,
    -- Extended columns for versioning system
    version_number     integer,
    is_current         boolean         DEFAULT true,
    change_reason      text,
    user_ip            text,
    application_name   text            DEFAULT current_setting('application_name')
);

-- Performance indexes for common queries
CREATE INDEX IF NOT EXISTS idx_t_history_tstamp ON {AUDIT_SCHEMA}.t_history (tstamp);
CREATE INDEX IF NOT EXISTS idx_t_history_schema_table ON {AUDIT_SCHEMA}.t_history (schemaname, tabname);
CREATE INDEX IF NOT EXISTS idx_t_history_user ON {AUDIT_SCHEMA}.t_history (who);
CREATE INDEX IF NOT EXISTS idx_t_history_operation ON {AUDIT_SCHEMA}.t_history (operation);
CREATE INDEX IF NOT EXISTS idx_t_history_table_version ON {AUDIT_SCHEMA}.t_history (schemaname, tabname, version_number);
CREATE INDEX IF NOT EXISTS idx_t_history_current ON {AUDIT_SCHEMA}.t_history (schemaname, tabname, is_current) WHERE is_current = true;

-- Function to calculate next version number
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.get_next_version(p_schema text, p_table text, p_operation text)
RETURNS integer AS
$BODY$
DECLARE
    next_version integer;
BEGIN
    -- For INSERT, version is always 1
    IF p_operation = 'INSERT' THEN
        RETURN 1;
    END IF;
    
    -- For UPDATE and DELETE, increment existing version
    SELECT COALESCE(MAX(version_number), 0) + 1
    INTO next_version
    FROM {AUDIT_SCHEMA}.t_history
    WHERE schemaname = p_schema AND tabname = p_table;
    
    RETURN next_version;
END;
$BODY$
LANGUAGE plpgsql;

-- Enhanced trigger function with versioning support (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.notify_with_versioning()
    RETURNS trigger AS
    $BODY$
    DECLARE
        epoc float := extract(epoch from now() at time zone 'utc');
        next_version integer;
        change_reason_val text;
        user_ip_val text;
    BEGIN
        -- Get next version number
        next_version := {AUDIT_SCHEMA}.get_next_version(TG_TABLE_SCHEMA, TG_RELNAME, TG_OP);
        
        -- Extract additional metadata if available
        change_reason_val := current_setting('audit.change_reason', true);
        user_ip_val := current_setting('audit.user_ip', true);
        
        -- Mark previous versions as not current for UPDATE and DELETE
        IF TG_OP IN ('UPDATE', 'DELETE') THEN
            UPDATE {AUDIT_SCHEMA}.t_history 
            SET is_current = false 
            WHERE schemaname = TG_TABLE_SCHEMA 
            AND tabname = TG_RELNAME 
            AND is_current = true;
        END IF;
        
        -- Insert new audit record with versioning
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO {AUDIT_SCHEMA}.t_history (
                epoc, tabname, schemaname, operation, new_val, old_val,
                version_number, is_current, change_reason, user_ip
            ) VALUES (
                epoc, TG_RELNAME, TG_TABLE_SCHEMA, TG_OP, 
                row_to_json(NEW), row_to_json(OLD),
                next_version, false, change_reason_val, user_ip_val
            );
            RETURN OLD;
            
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO {AUDIT_SCHEMA}.t_history (
                epoc, tabname, schemaname, operation, new_val, old_val,
                version_number, is_current, change_reason, user_ip
            ) VALUES (
                epoc, TG_RELNAME, TG_TABLE_SCHEMA, TG_OP, 
                row_to_json(NEW), row_to_json(OLD),
                next_version, true, change_reason_val, user_ip_val
            );
            RETURN NEW;
            
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO {AUDIT_SCHEMA}.t_history (
                epoc, tabname, schemaname, operation, new_val,
                version_number, is_current, change_reason, user_ip
            ) VALUES (
                epoc, TG_RELNAME, TG_TABLE_SCHEMA, TG_OP, 
                row_to_json(NEW),
                next_version, true, change_reason_val, user_ip_val
            );
            RETURN NEW;
        END IF;
    END;
    $BODY$
    LANGUAGE plpgsql VOLATILE COST 100
    SECURITY DEFINER;

-- Set proper ownership and permissions
COMMENT ON FUNCTION {AUDIT_SCHEMA}.notify_with_versioning() IS 
'Audit trigger function with SECURITY DEFINER - allows all users to write audit logs without direct privileges on logging tables';

-- Function to set change reason (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.set_change_reason(reason text)
RETURNS void AS
$BODY$
BEGIN
    PERFORM set_config('audit.change_reason', reason, false);
END;
$BODY$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Function to set user IP address (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.set_user_ip(ip_address text)
RETURNS void AS
$BODY$
BEGIN
    PERFORM set_config('audit.user_ip', ip_address, false);
END;
$BODY$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Function to get table change history (SECURITY DEFINER for read access)
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.get_table_history(
    p_schema text, 
    p_table text, 
    p_limit integer DEFAULT 100
)
RETURNS TABLE (
    id integer,
    timestamp_change timestamp,
    version_number integer,
    operation text,
    user_name text,
    change_reason text,
    old_values json,
    new_values json
) AS
$BODY$
BEGIN
    RETURN QUERY
    SELECT 
        h.id,
        h.tstamp,
        h.version_number,
        h.operation,
        h.who,
        h.change_reason,
        h.old_val,
        h.new_val
    FROM {AUDIT_SCHEMA}.t_history h
    WHERE h.schemaname = p_schema 
    AND h.tabname = p_table
    ORDER BY h.tstamp DESC, h.version_number DESC
    LIMIT p_limit;
END;
$BODY$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Grant execute permissions to public (all users can read audit logs)
GRANT EXECUTE ON FUNCTION {AUDIT_SCHEMA}.get_table_history(text, text, integer) TO public;
GRANT EXECUTE ON FUNCTION {AUDIT_SCHEMA}.set_change_reason(text) TO public;
GRANT EXECUTE ON FUNCTION {AUDIT_SCHEMA}.set_user_ip(text) TO public;

-- Table to track rollback operations
CREATE TABLE IF NOT EXISTS {AUDIT_SCHEMA}.t_rollback_history (
    id serial PRIMARY KEY,
    rollback_timestamp timestamp DEFAULT now(),
    rollback_user text DEFAULT current_user,
    target_schema text,
    target_table text,
    rollback_reason text,
    records_affected integer,
    rollback_to_version integer,
    rollback_to_timestamp timestamp,
    success boolean DEFAULT false
);

-- Function to rollback a single record to specific version (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.rollback_record_to_version(
    p_schema text,
    p_table text, 
    p_version integer,
    p_reason text DEFAULT 'Manual rollback'
)
RETURNS boolean AS
$BODY$
DECLARE
    record_data json;
    sql_query text;
    key_value text;
    affected_rows integer;
BEGIN
    -- Get data from requested version
    SELECT 
        CASE WHEN operation = 'DELETE' THEN old_val ELSE new_val END
    INTO record_data
    FROM {AUDIT_SCHEMA}.t_history
    WHERE schemaname = p_schema AND tabname = p_table AND version_number = p_version
    ORDER BY tstamp DESC LIMIT 1;
    
    IF record_data IS NULL THEN
        RAISE EXCEPTION 'Version % not found for %.%', p_version, p_schema, p_table;
    END IF;
    
    -- Set rollback reason
    PERFORM {AUDIT_SCHEMA}.set_change_reason('ROLLBACK: ' || p_reason);
    
    key_value := record_data->>'id';
    
    -- Build update query
    sql_query := format('UPDATE %I.%I SET ', p_schema, p_table);
    
    SELECT string_agg(
        format('%I = %s', key, 
            CASE 
                WHEN value::text = 'null' THEN 'NULL'
                WHEN jsonb_typeof(value::jsonb) = 'string' THEN quote_literal(value::text)
                ELSE value::text
            END
        ), ', '
    ) INTO sql_query
    FROM json_each(record_data) WHERE key != 'id';
    
    sql_query := sql_query || format(' WHERE id = %s', quote_literal(key_value));
    
    -- Execute rollback
    EXECUTE sql_query;
    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    
    -- Log rollback operation
    INSERT INTO {AUDIT_SCHEMA}.t_rollback_history 
    (target_schema, target_table, rollback_reason, records_affected, rollback_to_version, success)
    VALUES (p_schema, p_table, p_reason, affected_rows, p_version, true);
    
    RETURN true;
    
EXCEPTION WHEN OTHERS THEN
    INSERT INTO {AUDIT_SCHEMA}.t_rollback_history 
    (target_schema, target_table, rollback_reason, records_affected, rollback_to_version, success)
    VALUES (p_schema, p_table, p_reason || ' - ERROR: ' || SQLERRM, 0, p_version, false);
    
    RAISE EXCEPTION 'Error during rollback: %', SQLERRM;
END;
$BODY$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Function to undo user changes within time window (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION {AUDIT_SCHEMA}.undo_user_changes(
    p_user text,
    p_minutes_ago integer DEFAULT 60,
    p_reason text DEFAULT 'Undo user modifications',
    p_dry_run boolean DEFAULT true
)
RETURNS text AS
$BODY$
DECLARE
    change_cursor CURSOR FOR
        SELECT schemaname, tabname, old_val, new_val, operation, tstamp
        FROM {AUDIT_SCHEMA}.t_history
        WHERE who = p_user 
        AND tstamp >= NOW() - (p_minutes_ago || ' minutes')::interval
        AND operation IN ('UPDATE', 'DELETE')
        ORDER BY tstamp DESC;
    
    sql_query text;
    counter integer := 0;
    result_message text;
BEGIN
    IF p_dry_run THEN
        result_message := 'DRY RUN - Changes by ' || p_user || ' that would be undone:' || E'\\n';
        
        FOR change_row IN change_cursor LOOP
            result_message := result_message || format('- %s: %s.%s at %s', 
                change_row.operation, change_row.schemaname, change_row.tabname, change_row.tstamp) || E'\\n';
            counter := counter + 1;
        END LOOP;
        
        result_message := result_message || E'\\nTotal changes to undo: ' || counter;
        
    ELSE
        PERFORM {AUDIT_SCHEMA}.set_change_reason('UNDO USER: ' || p_reason);
        
        FOR change_row IN change_cursor LOOP
            IF change_row.operation = 'UPDATE' AND change_row.old_val IS NOT NULL THEN
                -- Restore previous values
                sql_query := format('UPDATE %I.%I SET ', change_row.schemaname, change_row.tabname);
                
                SELECT string_agg(
                    format('%I = %s', key, 
                        CASE 
                            WHEN value::text = 'null' THEN 'NULL'
                            WHEN jsonb_typeof(value::jsonb) = 'string' THEN quote_literal(value::text)
                            ELSE value::text
                        END
                    ), ', '
                ) INTO sql_query
                FROM json_each(change_row.old_val) WHERE key != 'id';
                
                sql_query := sql_query || format(' WHERE id = %s', quote_literal(change_row.old_val->>'id'));
                
                EXECUTE sql_query;
                counter := counter + 1;
                
            ELSIF change_row.operation = 'DELETE' AND change_row.old_val IS NOT NULL THEN
                -- Restore deleted record
                SELECT 
                    format('INSERT INTO %I.%I (%s) VALUES (%s)', 
                        change_row.schemaname, change_row.tabname,
                        string_agg(quote_ident(key), ', '),
                        string_agg(
                            CASE 
                                WHEN value::text = 'null' THEN 'NULL'
                                WHEN jsonb_typeof(value::jsonb) = 'string' THEN quote_literal(value::text)
                                ELSE value::text
                            END, ', '
                        )
                    )
                INTO sql_query
                FROM json_each(change_row.old_val);
                
                EXECUTE sql_query;
                counter := counter + 1;
            END IF;
        END LOOP;
        
        result_message := 'Undo completed. Changes restored: ' || counter;
    END IF;
    
    RETURN result_message;
END;
$BODY$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Views for easy access
CREATE OR REPLACE VIEW {AUDIT_SCHEMA}.v_current_versions AS
SELECT 
    schemaname,
    tabname,
    version_number,
    tstamp as last_modified,
    who as last_modified_by,
    operation as last_operation,
    change_reason,
    new_val as current_data
FROM {AUDIT_SCHEMA}.t_history
WHERE is_current = true
ORDER BY schemaname, tabname;

CREATE OR REPLACE VIEW {AUDIT_SCHEMA}.v_recent_changes AS
SELECT 
    tstamp,
    who as user_name,
    schemaname || '.' || tabname as table_name,
    operation,
    version_number,
    change_reason,
    CASE 
        WHEN operation = 'UPDATE' THEN 'Modified'
        WHEN operation = 'INSERT' THEN 'Created' 
        WHEN operation = 'DELETE' THEN 'Deleted'
    END as action_type,
    old_val->>'id' as record_id
FROM {AUDIT_SCHEMA}.t_history
WHERE tstamp >= CURRENT_DATE
ORDER BY tstamp DESC;

CREATE OR REPLACE VIEW {AUDIT_SCHEMA}.v_rollback_summary AS
SELECT 
    rollback_timestamp,
    rollback_user,
    target_schema || '.' || target_table as table_name,
    rollback_reason,
    records_affected,
    success
FROM {AUDIT_SCHEMA}.t_rollback_history
ORDER BY rollback_timestamp DESC;
        """


# =====================================================
# MAIN PLUGIN CLASS
# =====================================================

class AuditSystemManager:
    """QGIS plugin for audit system management"""
    
    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        
        # Initialize variables
        self.db_connection = None
        self.dialog = None
        
        # Check Qt compatibility
        self.qt_version = self._check_qt_compatibility()
        
        # Load database settings safely
        self.db_params = self._load_initial_db_settings()
        
        # Timer for automatic refresh
        self.auto_refresh_timer = QTimer()
        self.auto_refresh_timer.timeout.connect(self.refresh_recent_changes)
        
    def _load_initial_db_settings(self):
        """Load initial database settings with error handling"""
        try:
            return self.load_db_settings()
        except Exception as e:
            print(f"Error loading DB settings: {e}")
            return {
                'host': 'localhost',
                'database': '',
                'user': '',
                'password': '',
                'port': DEFAULT_PORT
            }
        
    def load_db_settings(self):
        """Load database settings from QSettings"""
        settings = QSettings()
        return {
            'host': settings.value('AuditSystem/db_host', 'localhost'),
            'database': settings.value('AuditSystem/db_name', ''),
            'user': settings.value('AuditSystem/db_user', ''),
            'password': settings.value('AuditSystem/db_password', ''),
            'port': settings.value('AuditSystem/db_port', DEFAULT_PORT)
        }
    
    def save_db_settings(self, db_params):
        """Save database settings to QSettings"""
        settings = QSettings()
        settings.setValue('AuditSystem/db_host', db_params['host'])
        settings.setValue('AuditSystem/db_name', db_params['database'])
        settings.setValue('AuditSystem/db_user', db_params['user'])
        settings.setValue('AuditSystem/db_password', db_params['password'])
        settings.setValue('AuditSystem/db_port', db_params['port'])
        
    def clear_db_settings(self):
        """Clear saved database settings"""
        settings = QSettings()
        for key in ['db_host', 'db_name', 'db_user', 'db_password', 'db_port']:
            settings.remove(f'AuditSystem/{key}')
        self.db_params = self.load_db_settings()
        
    def _check_qt_compatibility(self):
        """Check Qt version compatibility"""
        try:
            from qgis.PyQt import QtCore
            qt_version = QtCore.QT_VERSION_STR
            print(f"Audit System Manager: Using Qt version {qt_version}")
            return qt_version
        except Exception as e:
            print(f"Audit System Manager: Qt version detection failed: {e}")
            return "Unknown"
        
    def initGui(self):
        """Initialize plugin GUI"""
        try:
            # Icon and main action
            icon_path = os.path.join(self.plugin_dir, 'icon.png')
            self.action = QAction(
                QIcon(icon_path if os.path.exists(icon_path) else ''),
                "Audit System Manager",
                self.iface.mainWindow()
            )
            self.action.triggered.connect(self.run)
            
            # Add to toolbar
            self.iface.addToolBarIcon(self.action)
            self.iface.addPluginToMenu("Audit System", self.action)
            
        except Exception as e:
            print(f"Error initializing plugin GUI: {e}")
            show_error_message(None, "Plugin Error", 
                f"Error initializing plugin:\n{str(e)}")
        
    def unload(self):
        """Remove plugin"""
        try:
            self.iface.removeToolBarIcon(self.action)
            self.iface.removePluginMenu("Audit System", self.action)
            
            if self.auto_refresh_timer.isActive():
                self.auto_refresh_timer.stop()
                
            # Close database connection
            if self.db_connection and not self.db_connection.closed:
                self.db_connection.close()
                
            # Close dialog if open
            if hasattr(self, 'dialog') and self.dialog:
                self.dialog.close()
                
        except Exception as e:
            print(f"Error during plugin unload: {e}")
            
    def run(self):
        """Launch main window"""
        try:
            # Check psycopg2 availability first
            if not PSYCOPG2_AVAILABLE:
                show_error_message(None, "Missing Dependency", 
                    "psycopg2 library is not available.\n\n"
                    "Please install it using:\n"
                    "pip install psycopg2-binary")
                return
            
            # Check if database settings are configured
            if not self.db_params.get('database') or not self.db_params.get('user'):
                reply = show_question(None, "Database Configuration", 
                    "Database connection not configured. Open configuration?")
                if reply == QMessageBox.Yes:
                    self.show_config_dialog()
                return
            
            # Try to connect to database
            try:
                self.connect_database()
            except Exception as db_error:
                show_error_message(None, "Database Connection Error", 
                    f"Unable to connect to database:\n{str(db_error)}\n\n"
                    f"Please check your database configuration.")
                
                reply = show_question(None, "Reconfigure Database", 
                    "Would you like to reconfigure the database connection?")
                if reply == QMessageBox.Yes:
                    self.show_config_dialog()
                return
            
            # Launch main dialog
            try:
                self.dialog = AuditDialog(self.db_connection, self.iface, self)
                self.dialog.show()
            except Exception as ui_error:
                show_error_message(None, "Interface Error", 
                    f"Error creating plugin interface:\n{str(ui_error)}")
                
        except Exception as e:
            # Catch-all for any unexpected errors
            show_error_message(None, "Plugin Error", 
                f"Unexpected error launching plugin:\n{str(e)}")
            print(f"Audit System Manager error: {e}")
            import traceback
            traceback.print_exc()
    
    def show_config_dialog(self):
        """Show configuration dialog"""
        try:
            config_dialog = DatabaseConfigDialog(self)
            if config_dialog.exec_() == QDialog.Accepted:
                # Try to connect with new settings
                try:
                    self.connect_database()
                    show_info_message(None, "Success", 
                                    "Database connection configured successfully!")
                    # Now launch main dialog
                    self.dialog = AuditDialog(self.db_connection, self.iface, self)
                    self.dialog.show()
                except Exception as e:
                    show_error_message(None, "Connection Error", f"Failed to connect: {str(e)}")
        except Exception as e:
            show_error_message(None, "Configuration Error", 
                f"Error opening configuration dialog: {str(e)}")
            print(f"Config dialog error: {e}")
    
    def connect_database(self):
        """Connect to PostgreSQL database"""
        try:
            # Close existing connection if any
            if self.db_connection and not self.db_connection.closed:
                self.db_connection.close()
                
            if not PSYCOPG2_AVAILABLE:
                raise Exception("psycopg2 library not available. Please install it.")
            
            # Validate connection parameters
            required_params = ['host', 'database', 'user']
            missing_params = [p for p in required_params if not self.db_params.get(p)]
            if missing_params:
                raise Exception(f"Missing required parameters: {', '.join(missing_params)}")
            
            self.db_connection = psycopg2.connect(
                host=self.db_params['host'],
                database=self.db_params['database'],
                user=self.db_params['user'],
                password=self.db_params.get('password', ''),
                port=self.db_params.get('port', DEFAULT_PORT),
                connect_timeout=10  # 10 second timeout
            )
            
            # Test the connection
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT 1;")
            cursor.close()
            
        except Exception as e:
            self.db_connection = None
            raise Exception(f"Database connection error: {str(e)}")
                
    def refresh_recent_changes(self):
        """Refresh recent changes automatically"""
        try:
            if hasattr(self, 'dialog') and self.dialog and self.dialog.isVisible():
                if hasattr(self.dialog, 'load_recent_changes'):
                    self.dialog.load_recent_changes()
        except Exception as e:
            print(f"Error refreshing recent changes: {e}")
            # Stop auto-refresh if there's an error
            if self.auto_refresh_timer.isActive():
                self.auto_refresh_timer.stop()
            
    def update_db_params(self, new_params):
        """Update database parameters"""
        self.db_params = new_params
        self.save_db_settings(new_params)


# =====================================================
# MAIN DIALOG CLASS
# =====================================================

class AuditDialog(QDialog):
    """Main audit system window"""
    
    def __init__(self, db_connection, iface, manager):
        super().__init__()
        self.db_connection = db_connection
        self.iface = iface
        self.manager = manager
        self.help_dialog = None
        
        # Initialize UI state flags
        self.ui_initialized = False
        self.data_loading = False
        
        # Timer for auto-refresh
        self.auto_refresh_timer = QTimer()
        self.auto_refresh_timer.timeout.connect(self.refresh_all_data)
        
        # Timer for real-time monitoring
        self.real_time_timer = QTimer()
        
        try:
            # Setup UI first
            self.setupUI()
            self.ui_initialized = True
            
            # Setup enhanced features after UI is ready
            QTimer.singleShot(50, self._setup_enhanced_features)
            
            # Load initial data after UI is ready
            if self.db_connection and not self.db_connection.closed:
                QTimer.singleShot(100, self.safe_load_initial_data)
            else:
                print("Warning: No database connection available for initial data load")
                
        except Exception as e:
            print(f"Error initializing AuditDialog: {e}")
            show_error_message(None, "Initialization Error", 
                f"Error initializing plugin interface: {str(e)}")
            return
            
    def _setup_enhanced_features(self):
        """Setup enhanced features after UI is ready"""
        try:
            self.setup_real_time_monitoring()
            self.setup_advanced_search()
            self.setup_batch_operations()
            
            # Enhance load_statistics to include hourly activity
            original_load_stats = self.load_statistics
            def enhanced_load_statistics():
                original_load_stats()
                self.load_hourly_activity_stats()
            self.load_statistics = enhanced_load_statistics
            
        except Exception as e:
            print(f"Error setting up enhanced features: {e}")
    
    def safe_load_initial_data(self):
        """Safely load initial data with proper error handling"""
        try:
            if not self.ui_initialized or self.data_loading:
                return
                
            self.data_loading = True
            
            # Check if audit system exists first
            if not self._check_audit_system_exists():
                print("Warning: Audit system not installed - skipping data load")
                self._show_audit_system_info()
                return
            
            # Load data components one by one with error handling
            self._load_users_safe()
            self._load_recent_changes_safe()
            self._load_statistics_safe()
            self._load_rollback_history_safe()
            self._load_system_info_safe()
            
        except Exception as e:
            print(f"Error loading initial data: {e}")
        finally:
            self.data_loading = False
    
    def _check_audit_system_exists(self):
        """Check if audit system exists without throwing errors"""
        try:
            if not self.db_connection or self.db_connection.closed:
                return False
                
            cursor = self.db_connection.cursor()
            cursor.execute("""
                SELECT EXISTS(
                    SELECT 1 FROM information_schema.tables 
                    WHERE table_schema = %s AND table_name = 't_history'
                );
            """, (AUDIT_SCHEMA,))
            
            result = cursor.fetchone()[0]
            cursor.close()
            return result
            
        except Exception as e:
            print(f"Error checking audit system: {e}")
            return False
    
    def _show_audit_system_info(self):
        """Show information about missing audit system"""
        try:
            if hasattr(self, 'status_label') and self.status_label:
                self.status_label.setText("Audit system not installed")
                self.status_label.setStyleSheet("color: orange; font-weight: bold;")
        except Exception as e:
            print(f"Error updating status label: {e}")
    
    def _load_users_safe(self):
        """Safely load users with error handling"""
        try:
            if not self.db_connection or self.db_connection.closed:
                return
                
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT DISTINCT who 
                FROM {AUDIT_SCHEMA}.t_history 
                WHERE tstamp >= CURRENT_DATE - INTERVAL '7 days'
                ORDER BY who
            """)
            
            users = [row[0] for row in cursor.fetchall()]
            
            # Update user combo boxes safely
            if hasattr(self, 'user_filter') and self.user_filter:
                self.user_filter.clear()
                self.user_filter.addItem("All users")
                self.user_filter.addItems(users)
            
            # Rollback user combo
            if hasattr(self, 'rollback_user') and self.rollback_user:
                self.rollback_user.clear()
                self.rollback_user.addItems(users)
            
            cursor.close()
            
        except Exception as e:
            print(f"Error loading users: {e}")
    
    def _load_recent_changes_safe(self):
        """Safely load recent changes with error handling"""
        try:
            self.load_recent_changes()
        except Exception as e:
            print(f"Error loading recent changes: {e}")
    
    def _load_statistics_safe(self):
        """Safely load statistics with error handling"""
        try:
            self.load_statistics()
        except Exception as e:
            print(f"Error loading statistics: {e}")
    
    def _load_rollback_history_safe(self):
        """Safely load rollback history with error handling"""
        try:
            self.load_rollback_history()
        except Exception as e:
            print(f"Error loading rollback history: {e}")
    
    def _load_system_info_safe(self):
        """Safely load system info with error handling"""
        try:
            self.load_system_info()
        except Exception as e:
            print(f"Error loading system info: {e}")
        
    def setupUI(self):
        """Configure user interface"""
        self.setWindowTitle("Audit System Manager")
        self.setMinimumSize(1200, 800)
        
        # Main layout
        main_layout = QVBoxLayout()
        
        # Header with database info
        header_layout = self._create_header_layout()
        
        # Main tab widget
        self.tab_widget = QTabWidget()
        
        # Setup all tabs
        self.setup_monitoring_tab()
        self.setup_versioning_tab()
        self.setup_rollback_tab()
        self.setup_stats_tab()
        self.setup_config_tab()
        
        main_layout.addLayout(header_layout)
        main_layout.addWidget(self.tab_widget)
        
        self.setLayout(main_layout)
        
    def _create_header_layout(self):
        """Create header layout with status and controls"""
        header_layout = QHBoxLayout()
        
        self.status_label = QLabel("Database connected")
        self.status_label.setStyleSheet("color: green; font-weight: bold;")
        
        self.refresh_btn = QPushButton("Refresh")
        self.refresh_btn.clicked.connect(self.refresh_all_data)
        
        # Auto-refresh
        self.auto_refresh_check = QCheckBox("Auto-refresh (30s)")
        self.auto_refresh_check.toggled.connect(self.toggle_auto_refresh)
        
        # Help button
        self.help_btn = QPushButton("Help")
        self.help_btn.clicked.connect(self.show_help)
        
        header_layout.addWidget(self.status_label)
        header_layout.addStretch()
        header_layout.addWidget(self.auto_refresh_check)
        header_layout.addWidget(self.refresh_btn)
        header_layout.addWidget(self.help_btn)
        
        return header_layout
        
    def setup_monitoring_tab(self):
        """Real-time monitoring tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Monitoring filters
        filter_layout = self._create_monitoring_filters()
        
        # Recent changes table
        self.recent_changes_table = self._create_recent_changes_table()
        
        # Quick action buttons
        actions_layout = self._create_monitoring_actions()
        
        layout.addLayout(filter_layout)
        layout.addWidget(self.recent_changes_table)
        layout.addLayout(actions_layout)
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Monitoring")
        
    def _create_monitoring_filters(self):
        """Create monitoring filters layout with cascading dropdowns"""
        filter_layout = QVBoxLayout()
        
        # Quick Actions Toolbar - 🥇 FEATURE 1
        toolbar_layout = self._create_quick_actions_toolbar()
        filter_layout.addLayout(toolbar_layout)
        
        # Smart Search Box - 🥈 FEATURE 2  
        search_layout = self._create_smart_search_box()
        filter_layout.addLayout(search_layout)
        
        # Standard filters with schema->table cascading
        standard_filters_layout = QHBoxLayout()
        
        # User filter
        self.user_filter = QComboBox()
        self.user_filter.addItem("All users")
        self.user_filter.currentTextChanged.connect(self.filter_recent_changes)
        
        # Schema filter with cascading table loading
        self.schema_filter = QComboBox()
        self.schema_filter.addItems(["All schemas"] + DEFAULT_SCHEMAS)
        self.schema_filter.currentTextChanged.connect(self._on_schema_changed)
        
        # Table filter (populated based on schema selection)
        self.table_filter = QComboBox()
        self.table_filter.addItem("All tables")
        self.table_filter.currentTextChanged.connect(self.filter_recent_changes)
        
        # Time filter
        self.time_filter = QComboBox()
        self.time_filter.addItems(list(TIME_INTERVALS.keys()))
        self.time_filter.currentTextChanged.connect(self.filter_recent_changes)
        
        standard_filters_layout.addWidget(QLabel("User:"))
        standard_filters_layout.addWidget(self.user_filter)
        standard_filters_layout.addWidget(QLabel("Schema:"))
        standard_filters_layout.addWidget(self.schema_filter)
        standard_filters_layout.addWidget(QLabel("Table:"))
        standard_filters_layout.addWidget(self.table_filter)
        standard_filters_layout.addWidget(QLabel("Period:"))
        standard_filters_layout.addWidget(self.time_filter)
        standard_filters_layout.addStretch()
        
        filter_layout.addLayout(standard_filters_layout)
        
        # Load initial tables for first schema
        QTimer.singleShot(100, lambda: self._on_schema_changed("All schemas"))
        
        return filter_layout
        
    def _create_quick_actions_toolbar(self):
        """🥇 Create Quick Actions Toolbar - FEATURE 1"""
        toolbar_layout = QHBoxLayout()
        
        # Style for toolbar buttons
        toolbar_style = """
            QPushButton {
                background-color: #f0f8ff;
                border: 1px solid #b0c4de;
                border-radius: 4px;
                padding: 6px 12px;
                font-weight: bold;
                margin: 2px;
            }
            QPushButton:hover {
                background-color: #e6f3ff;
                border: 1px solid #4682b4;
            }
            QPushButton:pressed {
                background-color: #d4e6f1;
            }
        """
        
        # Quick action buttons
        actions = [
            ("🔄 Refresh", "Refresh all data", self.refresh_all_data),
            ("📅 Today", "Show today's changes only", self._filter_today),
            ("👤 My Changes", "Show only my changes", self._filter_my_changes),
            ("⚡ Last 50", "Show last 50 changes", self._filter_last_50),
            ("📤 Export", "Export current view", self.export_changes),
            ("❓ Help", "Open help documentation", self.show_help),
        ]
        
        self.quick_buttons = {}
        
        for text, tooltip, handler in actions:
            btn = QPushButton(text)
            btn.setToolTip(tooltip)
            btn.setStyleSheet(toolbar_style)
            btn.clicked.connect(handler)
            btn.setMaximumHeight(35)
            
            toolbar_layout.addWidget(btn)
            self.quick_buttons[text] = btn
        
        toolbar_layout.addStretch()
        
        # Add a separator line
        separator = QLabel()
        separator.setStyleSheet("border-bottom: 1px solid #ccc; margin: 5px 0px;")
        separator.setMaximumHeight(1)
        
        final_layout = QVBoxLayout()
        final_layout.addLayout(toolbar_layout)
        final_layout.addWidget(separator)
        
        return final_layout
        
    def _create_smart_search_box(self):
        """🥈 Create Smart Search with History - FEATURE 2"""
        search_layout = QHBoxLayout()
        
        # Search label
        search_label = QLabel("🔍 Smart Search:")
        search_label.setStyleSheet("font-weight: bold; color: #2c3e50;")
        
        # Main search box
        self.smart_search_box = QLineEdit()
        self.smart_search_box.setPlaceholderText("Search in all data... (try: user:giovanni, table:users, today, delete)")
        self.smart_search_box.returnPressed.connect(self._execute_smart_search)
        
        # Search history dropdown
        self.search_history_btn = QPushButton("📜")
        self.search_history_btn.setToolTip("Search History")
        self.search_history_btn.setMaximumWidth(30)
        self.search_history_btn.clicked.connect(self._show_search_history)
        
        # Quick filter buttons
        quick_filters = [
            ("INSERT", "operation = 'INSERT'"),
            ("UPDATE", "operation = 'UPDATE'"), 
            ("DELETE", "operation = 'DELETE'"),
            ("Today", "today"),
            ("Errors", "change_reason LIKE '%error%'"),
        ]
        
        self.quick_filter_buttons = {}
        
        for label, filter_value in quick_filters:
            btn = QPushButton(label)
            btn.setMaximumHeight(25)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #ecf0f1;
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    padding: 2px 8px;
                    font-size: 9px;
                }
                QPushButton:hover { background-color: #d5dbdb; }
                QPushButton:checked { 
                    background-color: #3498db; 
                    color: white; 
                    border: 1px solid #2980b9;
                }
            """)
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, f=filter_value: self._apply_quick_filter(f, checked))
            
            self.quick_filter_buttons[label] = btn
        
        # Layout assembly
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.smart_search_box, 3)  # Takes more space
        search_layout.addWidget(self.search_history_btn)
        
        # Add quick filter buttons
        for btn in self.quick_filter_buttons.values():
            search_layout.addWidget(btn)
            
        search_layout.addStretch()
        
        # Initialize search history
        self.search_history = []
        
        return search_layout
        
    def _on_schema_changed(self, schema_name):
        """Handle schema selection change - populate tables dropdown"""
        try:
            if not self.db_connection or self.db_connection.closed:
                return
                
            # Clear current table filter
            self.table_filter.clear()
            self.table_filter.addItem("All tables")
            
            if schema_name == "All schemas":
                return
                
            # Load tables for selected schema
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT DISTINCT h.tabname
                FROM {AUDIT_SCHEMA}.t_history h
                WHERE h.schemaname = %s
                ORDER BY h.tabname
            """, (schema_name,))
            
            tables = [row[0] for row in cursor.fetchall()]
            
            if tables:
                self.table_filter.addItems(tables)
            
            cursor.close()
            
            # Auto-refresh with new schema
            self.filter_recent_changes()
            
        except Exception as e:
            print(f"Error loading tables for schema {schema_name}: {e}")
            
    # Quick Actions Implementations
    def _filter_today(self):
        """Filter to show only today's changes"""
        self.time_filter.setCurrentText("Today")
        self.filter_recent_changes()
        
    def _filter_my_changes(self):
        """Filter to show only current user's changes"""
        try:
            if self.db_connection and not self.db_connection.closed:
                cursor = self.db_connection.cursor()
                cursor.execute("SELECT current_user")
                current_user = cursor.fetchone()[0]
                cursor.close()
                
                # Set user filter to current user
                index = self.user_filter.findText(current_user)
                if index >= 0:
                    self.user_filter.setCurrentIndex(index)
                else:
                    # Add current user if not in list
                    self.user_filter.addItem(current_user)
                    self.user_filter.setCurrentText(current_user)
                    
                self.filter_recent_changes()
                
        except Exception as e:
            print(f"Error filtering my changes: {e}")
            
    def _filter_last_50(self):
        """Show last 50 changes with visual feedback"""
        # This is handled in the query, but we can give visual feedback
        self.status_label.setText("Showing last 50 changes")
        self.load_recent_changes()
        
    # Smart Search Implementations  
    def _execute_smart_search(self):
        """🥈 Execute smart search with advanced parsing"""
        search_text = self.smart_search_box.text().strip()
        
        if not search_text:
            return
            
        # Add to search history
        if search_text not in self.search_history:
            self.search_history.insert(0, search_text)
            self.search_history = self.search_history[:10]  # Keep last 10
            
        try:
            # Parse smart search syntax
            filters = self._parse_smart_search(search_text)
            
            # Apply parsed filters
            self._apply_smart_filters(filters)
            
            # Update status
            self.status_label.setText(f"Smart search: '{search_text}' - {len(filters)} filters applied")
            
        except Exception as e:
            show_error_message(self, "Search Error", f"Error in smart search: {str(e)}")
            
    def _parse_smart_search(self, search_text):
        """Parse smart search syntax into filter components"""
        filters = {}
        
        # Handle special keywords first
        if "today" in search_text.lower():
            filters['time'] = "Today"
            search_text = search_text.lower().replace("today", "").strip()
            
        if "yesterday" in search_text.lower():
            filters['time'] = "Last 3 days"  # Closest we have
            search_text = search_text.lower().replace("yesterday", "").strip()
            
        # Handle specific syntax: "user:name", "table:name", etc.
        import re
        
        # user:username
        user_match = re.search(r'user:(\w+)', search_text, re.IGNORECASE)
        if user_match:
            filters['user'] = user_match.group(1)
            search_text = re.sub(r'user:\w+', '', search_text, flags=re.IGNORECASE).strip()
            
        # table:tablename  
        table_match = re.search(r'table:(\w+)', search_text, re.IGNORECASE)
        if table_match:
            filters['table'] = table_match.group(1)
            search_text = re.sub(r'table:\w+', '', search_text, flags=re.IGNORECASE).strip()
            
        # schema:schemaname
        schema_match = re.search(r'schema:(\w+)', search_text, re.IGNORECASE)
        if schema_match:
            filters['schema'] = schema_match.group(1)
            search_text = re.sub(r'schema:\w+', '', search_text, flags=re.IGNORECASE).strip()
            
        # operation type (insert, update, delete)
        for op in ['INSERT', 'UPDATE', 'DELETE']:
            if op.lower() in search_text.lower():
                filters['operation'] = op
                search_text = search_text.lower().replace(op.lower(), "").strip()
                break
                
        # Remaining text is general search
        if search_text:
            filters['general'] = search_text
            
        return filters
        
    def _apply_smart_filters(self, filters):
        """Apply parsed smart filters to the interface"""
        # Apply time filter
        if 'time' in filters:
            index = self.time_filter.findText(filters['time'])
            if index >= 0:
                self.time_filter.setCurrentIndex(index)
                
        # Apply user filter
        if 'user' in filters:
            index = self.user_filter.findText(filters['user'])
            if index >= 0:
                self.user_filter.setCurrentIndex(index)
            else:
                # Try partial match
                for i in range(self.user_filter.count()):
                    if filters['user'].lower() in self.user_filter.itemText(i).lower():
                        self.user_filter.setCurrentIndex(i)
                        break
                        
        # Apply schema filter
        if 'schema' in filters:
            index = self.schema_filter.findText(filters['schema'])
            if index >= 0:
                self.schema_filter.setCurrentIndex(index)
                
        # Apply table filter (after schema is set)
        if 'table' in filters:
            QTimer.singleShot(100, lambda: self._set_table_filter(filters['table']))
            
        # Apply operation filter via quick buttons
        if 'operation' in filters:
            op = filters['operation']
            if op in self.quick_filter_buttons:
                self.quick_filter_buttons[op].setChecked(True)
                
        # For general search, we'll need to enhance the main query
        # This will be handled in the enhanced load_recent_changes method
        
        # Trigger data refresh
        QTimer.singleShot(150, self.filter_recent_changes)
        
    def _set_table_filter(self, table_name):
        """Set table filter with delay to allow schema loading"""
        index = self.table_filter.findText(table_name)
        if index >= 0:
            self.table_filter.setCurrentIndex(index)
        else:
            # Try partial match
            for i in range(self.table_filter.count()):
                if table_name.lower() in self.table_filter.itemText(i).lower():
                    self.table_filter.setCurrentIndex(i)
                    break
                    
    def _show_search_history(self):
        """Show search history dropdown"""
        if not self.search_history:
            show_info_message(self, "Search History", "No search history yet.")
            return
            
        # Create context menu with history
        menu = QMenu(self)
        
        for search in self.search_history:
            action = menu.addAction(f"🔍 {search}")
            action.triggered.connect(lambda checked, s=search: self._use_search_from_history(s))
            
        menu.addSeparator()
        clear_action = menu.addAction("🗑️ Clear History")
        clear_action.triggered.connect(self._clear_search_history)
        
        # Show menu at button position
        menu.exec_(self.search_history_btn.mapToGlobal(self.search_history_btn.rect().bottomLeft()))
        
    def _use_search_from_history(self, search_text):
        """Use a search from history"""
        self.smart_search_box.setText(search_text)
        self._execute_smart_search()
        
    def _clear_search_history(self):
        """Clear search history"""
        self.search_history.clear()
        show_info_message(self, "History Cleared", "Search history has been cleared.")
        
    def _apply_quick_filter(self, filter_value, checked):
        """Apply quick filter button"""
        if checked:
            # For now, we'll use the smart search functionality
            current_search = self.smart_search_box.text()
            if filter_value == "today":
                new_search = "today " + current_search
            elif filter_value in ["INSERT", "UPDATE", "DELETE"]:
                new_search = filter_value.lower() + " " + current_search
            else:
                new_search = filter_value + " " + current_search
                
            self.smart_search_box.setText(new_search.strip())
            self._execute_smart_search()
        else:
            # Remove filter - simplified approach
            self.filter_recent_changes()
        
    def _create_recent_changes_table(self):
        """Create recent changes table with enhanced functionality"""
        table = QTableWidget()
        table.setColumnCount(8)
        table.setHorizontalHeaderLabels([
            "Date/Time", "User", "Table", "Action", "Record ID", "Reason", "Version", "Debug Keys"
        ])
        table.horizontalHeader().setStretchLastSection(True)
        table.setAlternatingRowColors(True)
        table.setSortingEnabled(True)
        table.setContextMenuPolicy(Qt.CustomContextMenu)
        table.customContextMenuRequested.connect(self.show_table_context_menu)
        
        # Enable text selection and copying
        table.setSelectionBehavior(QAbstractItemView.SelectItems)
        table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        
        # Hide debug column by default
        table.setColumnHidden(7, True)
        
        # Connect double-click to copy Record ID
        table.cellDoubleClicked.connect(self.on_cell_double_clicked)
        
        return table
        
    def _create_monitoring_actions(self):
        """Create monitoring actions layout"""
        actions_layout = QHBoxLayout()
        
        self.view_details_btn = QPushButton("Details")
        self.view_details_btn.clicked.connect(self.show_record_details)
        
        self.quick_rollback_btn = QPushButton("Quick Rollback")
        self.quick_rollback_btn.clicked.connect(self.quick_rollback)
        
        self.export_btn = QPushButton("Export CSV")
        self.export_btn.clicked.connect(self.export_changes)
        
        actions_layout.addWidget(self.view_details_btn)
        actions_layout.addWidget(self.quick_rollback_btn)
        actions_layout.addWidget(self.export_btn)
        actions_layout.addStretch()
        
        return actions_layout

    def setup_versioning_tab(self):
        """Versioning tab with improved layout, record filtering and diff visualization"""
        tab = QWidget()
        layout = QVBoxLayout()

        title_label = QLabel("📦 Table Versioning and History")
        title_label.setStyleSheet("font-weight: bold; font-size: 16px; margin-bottom: 10px;")
        layout.addWidget(title_label)

        # Enhanced selection layout with record filter
        selection_group = QGroupBox("Table and Record Selection")
        selection_layout = QGridLayout()
        
        # Schema selection
        selection_layout.addWidget(QLabel("Schema:"), 0, 0)
        self.version_schema_combo = QComboBox()
        self.version_schema_combo.setMinimumWidth(150)
        self.version_schema_combo.currentTextChanged.connect(self.load_versioning_tables)
        selection_layout.addWidget(self.version_schema_combo, 0, 1)
        
        # Table selection
        selection_layout.addWidget(QLabel("Table:"), 0, 2)
        self.version_table_combo = QComboBox()
        self.version_table_combo.setMinimumWidth(200)
        self.version_table_combo.currentTextChanged.connect(self.on_versioning_table_changed)
        selection_layout.addWidget(self.version_table_combo, 0, 3)
        
        # NEW: Record ID filter
        selection_layout.addWidget(QLabel("Record ID:"), 1, 0)
        self.version_record_id_edit = QLineEdit()
        self.version_record_id_edit.setPlaceholderText("Enter specific record ID (optional)")
        self.version_record_id_edit.setMinimumWidth(150)
        selection_layout.addWidget(self.version_record_id_edit, 1, 1)
        
        # Load button and record count
        load_button = QPushButton("🔍 Load History")
        load_button.clicked.connect(self.load_table_history)
        selection_layout.addWidget(load_button, 1, 2)
        
        self.version_record_count_label = QLabel("0 versions")
        self.version_record_count_label.setStyleSheet("color: #666; font-style: italic;")
        selection_layout.addWidget(self.version_record_count_label, 1, 3)
        
        selection_group.setLayout(selection_layout)
        layout.addWidget(selection_group)

        # Enhanced table with better diff visualization
        history_group = QGroupBox("Version History")
        history_layout = QVBoxLayout()
        
        # Table controls
        table_controls_layout = QHBoxLayout()
        
        self.show_diff_check = QCheckBox("Show Differences Only")
        self.show_diff_check.setChecked(True)
        self.show_diff_check.toggled.connect(self.toggle_diff_view)
        table_controls_layout.addWidget(self.show_diff_check)
        
        self.compare_versions_btn = QPushButton("📊 Compare Selected Versions")
        self.compare_versions_btn.clicked.connect(self.compare_selected_versions)
        self.compare_versions_btn.setEnabled(False)
        table_controls_layout.addWidget(self.compare_versions_btn)
        
        table_controls_layout.addStretch()
        
        # Export button
        self.export_history_btn = QPushButton("📤 Export History")
        self.export_history_btn.clicked.connect(self.export_version_history)
        table_controls_layout.addWidget(self.export_history_btn)
        
        history_layout.addLayout(table_controls_layout)

        # Enhanced versioning table
        self.versioning_table = QTableWidget()
        self.versioning_table.setColumnCount(8)
        self.versioning_table.setHorizontalHeaderLabels([
            "Version", "Operation", "User", "Reason", "Timestamp", "Record ID", "Changes", "Actions"
        ])
        self.versioning_table.horizontalHeader().setStretchLastSection(True)
        self.versioning_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.versioning_table.setSelectionMode(QTableWidget.MultiSelection)
        self.versioning_table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.versioning_table.setAlternatingRowColors(True)
        
        # Connect selection change to enable/disable compare button
        self.versioning_table.selectionModel().selectionChanged.connect(self.on_version_selection_changed)
        
        # Add context menu
        self.versioning_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.versioning_table.customContextMenuRequested.connect(self.show_versioning_context_menu)
        
        history_layout.addWidget(self.versioning_table)
        history_group.setLayout(history_layout)
        layout.addWidget(history_group)

        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Versioning")

        # Populate schemas when the tab is set up
        self.populate_versioning_schemas()

    def on_versioning_table_changed(self):
        """Handle table selection change in versioning tab"""
        # Clear record ID when table changes
        if hasattr(self, 'version_record_id_edit'):
            self.version_record_id_edit.clear()
        
        # Clear current data
        if hasattr(self, 'versioning_table'):
            self.versioning_table.setRowCount(0)
            self.version_record_count_label.setText("0 versions")

    def on_version_selection_changed(self):
        """Handle version table selection changes"""
        try:
            selected_rows = set()
            for item in self.versioning_table.selectedItems():
                selected_rows.add(item.row())
            
            # Enable compare button if exactly 2 rows are selected
            self.compare_versions_btn.setEnabled(len(selected_rows) == 2)
            
        except Exception as e:
            print(f"Error handling selection change: {e}")

    def load_table_history(self):
        """Load versioned history for the selected table with optional record filtering"""
        schema = self.version_schema_combo.currentText()
        table = self.version_table_combo.currentText()
        record_id = self.version_record_id_edit.text().strip()
        
        if not schema or not table:
            show_error_message(self, "Warning", "Please select both schema and table.")
            return
            
        try:
            cursor = self.db_connection.cursor()
            
            # Build query with optional record ID filter
            base_query = f"""
                SELECT 
                    h.version_number, 
                    h.operation, 
                    h.who, 
                    COALESCE(h.change_reason, '-') as reason,
                    h.tstamp,
                    -- Extract record ID using enhanced detection
                    COALESCE(
                        CASE WHEN h.new_val->>'id' IS NOT NULL AND h.new_val->>'id' != '' THEN h.new_val->>'id' ELSE h.old_val->>'id' END,
                        CASE WHEN h.new_val->>'gid' IS NOT NULL AND h.new_val->>'gid' != '' THEN h.new_val->>'gid' ELSE h.old_val->>'gid' END,
                        CASE WHEN h.new_val->>'fid' IS NOT NULL AND h.new_val->>'fid' != '' THEN h.new_val->>'fid' ELSE h.old_val->>'fid' END,
                        CASE WHEN h.new_val->>'objectid' IS NOT NULL AND h.new_val->>'objectid' != '' THEN h.new_val->>'objectid' ELSE h.old_val->>'objectid' END,
                        'N/A'
                    ) as extracted_record_id,
                    h.old_val,
                    h.new_val
                FROM {AUDIT_SCHEMA}.t_history h
                WHERE h.schemaname = %s AND h.tabname = %s
            """
            
            params = [schema, table]
            
            # Add record ID filter if specified
            if record_id:
                record_filter = """
                    AND (
                        h.new_val->>'id' = %s OR h.old_val->>'id' = %s OR
                        h.new_val->>'gid' = %s OR h.old_val->>'gid' = %s OR
                        h.new_val->>'fid' = %s OR h.old_val->>'fid' = %s OR
                        h.new_val->>'objectid' = %s OR h.old_val->>'objectid' = %s
                    )
                """
                base_query += record_filter
                params.extend([record_id] * 8)  # Add record_id 8 times for all comparisons
                
            base_query += " ORDER BY h.tstamp DESC, h.version_number DESC LIMIT 200"
            
            cursor.execute(base_query, params)
            rows = cursor.fetchall()
            cursor.close()
            
            # Populate table with enhanced data
            self._populate_versioning_table(rows, record_id)
            
            # Update record count
            filter_text = f" for record '{record_id}'" if record_id else ""
            self.version_record_count_label.setText(f"{len(rows)} versions{filter_text}")
            
        except Exception as e:
            show_error_message(self, "Error", f"Failed to load table history: {e}")
            print(f"Versioning load error: {e}")

    def _populate_versioning_table(self, rows, filtered_record_id=None):
        """Populate versioning table with enhanced diff visualization"""
        self.versioning_table.setRowCount(len(rows))
        
        for i, row in enumerate(rows):
            version, operation, user, reason, timestamp, record_id, old_val, new_val = row
            
            # Version number
            version_item = QTableWidgetItem(str(version))
            bold_font = QFont("Arial", 9)
            bold_font.setBold(True)
            version_item.setFont(bold_font)
            self.versioning_table.setItem(i, 0, version_item)
            
            # Operation with color coding
            op_item = QTableWidgetItem(operation)
            if operation == 'INSERT':
                op_item.setBackground(QColor('#e8f5e8'))  # Light green
            elif operation == 'UPDATE':
                op_item.setBackground(QColor('#fff3e0'))  # Light orange
            elif operation == 'DELETE':
                op_item.setBackground(QColor('#ffebee'))  # Light red
            self.versioning_table.setItem(i, 1, op_item)
            
            # User
            self.versioning_table.setItem(i, 2, QTableWidgetItem(user))
            
            # Reason
            reason_item = QTableWidgetItem(reason)
            if reason == '-':
                reason_item.setForeground(QColor('#999'))
                italic_font = QFont("Arial", 8)
                italic_font.setItalic(True)
                reason_item.setFont(italic_font)
            self.versioning_table.setItem(i, 3, reason_item)
            
            # Timestamp
            formatted_time = format_timestamp(timestamp)
            self.versioning_table.setItem(i, 4, QTableWidgetItem(formatted_time))
            
            # Record ID
            record_item = QTableWidgetItem(record_id)
            bold_font = QFont("Arial", 9)
            bold_font.setBold(True)
            record_item.setFont(bold_font)
            if filtered_record_id and record_id == filtered_record_id:
                record_item.setBackground(QColor('#e3f2fd'))  # Highlight filtered record
            self.versioning_table.setItem(i, 5, record_item)
            
            # Changes summary
            changes_summary = self._generate_changes_summary(old_val, new_val, operation)
            changes_item = QTableWidgetItem(changes_summary)
            changes_item.setToolTip(changes_summary)  # Full text in tooltip
            self.versioning_table.setItem(i, 6, changes_item)
            
            # Actions button
            actions_btn = QPushButton("Details")
            actions_btn.clicked.connect(lambda checked, r=i: self.show_version_details(r))
            self.versioning_table.setCellWidget(i, 7, actions_btn)

    def _generate_changes_summary(self, old_val, new_val, operation):
        """Generate a human-readable summary of changes"""
        try:
            if operation == 'INSERT':
                if new_val:
                    field_count = len(new_val.keys()) if isinstance(new_val, dict) else 1
                    return f"Record created ({field_count} fields)"
                return "Record created"
                
            elif operation == 'DELETE':
                if old_val:
                    field_count = len(old_val.keys()) if isinstance(old_val, dict) else 1
                    return f"Record deleted ({field_count} fields)"
                return "Record deleted"
                
            elif operation == 'UPDATE':
                if not old_val or not new_val:
                    return "Data modified"
                    
                if not isinstance(old_val, dict) or not isinstance(new_val, dict):
                    return "Data modified (complex)"
                    
                # Find changed fields
                changed_fields = []
                all_keys = set(old_val.keys()) | set(new_val.keys())
                
                for key in all_keys:
                    old_value = old_val.get(key)
                    new_value = new_val.get(key)
                    if old_value != new_value:
                        changed_fields.append(key)
                
                if len(changed_fields) == 0:
                    return "No changes detected"
                elif len(changed_fields) <= 3:
                    return f"Modified: {', '.join(changed_fields)}"
                else:
                    return f"Modified {len(changed_fields)} fields: {', '.join(changed_fields[:2])}..."
                    
            return "Unknown operation"
            
        except Exception as e:
            print(f"Error generating changes summary: {e}")
            return "Error analyzing changes"

    def show_version_details(self, row):
        """Show detailed view of a specific version"""
        try:
            if row >= self.versioning_table.rowCount():
                return
                
            # Get data from table
            version_item = self.versioning_table.item(row, 0)
            operation_item = self.versioning_table.item(row, 1)
            user_item = self.versioning_table.item(row, 2)
            reason_item = self.versioning_table.item(row, 3)
            timestamp_item = self.versioning_table.item(row, 4)
            record_id_item = self.versioning_table.item(row, 5)
            
            if not all([version_item, operation_item, user_item, timestamp_item]):
                QMessageBox.warning(self, "Error", "Cannot retrieve version details.")
                return
            
            # Get full data from database
            schema = self.version_schema_combo.currentText()
            table = self.version_table_combo.currentText()
            version = version_item.text()
            
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT old_val, new_val, change_reason, tstamp, who, operation
                FROM {AUDIT_SCHEMA}.t_history
                WHERE schemaname = %s AND tabname = %s AND version_number = %s
                ORDER BY tstamp DESC LIMIT 1
            """, (schema, table, version))
            
            result = cursor.fetchone()
            cursor.close()
            
            if result:
                old_val, new_val, reason, tstamp, user, operation = result
                self._show_version_details_dialog(
                    version, operation, user, reason, tstamp, 
                    record_id_item.text(), old_val, new_val,
                    f"{schema}.{table}"
                )
            else:
                QMessageBox.warning(self, "Error", "Version data not found in database.")
                
        except Exception as e:
            show_error_message(self, "Error", f"Error showing version details: {e}")

    def _show_version_details_dialog(self, version, operation, user, reason, timestamp, record_id, old_val, new_val, table_name):
        """Show detailed version information in a dialog"""
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Version {version} Details - {table_name}")
        dialog.setMinimumSize(800, 600)
        
        layout = QVBoxLayout()
        
        # Header info
        header_info = f"""
        <b>Version Information:</b><br>
        Version: <b>{version}</b> | Operation: <b>{operation}</b> | User: <b>{user}</b><br>
        Timestamp: <b>{format_timestamp(timestamp)}</b><br>
        Record ID: <b>{record_id}</b> | Table: <b>{table_name}</b><br>
        Reason: <i>{reason or 'Not specified'}</i>
        """
        
        header_label = QLabel(header_info)
        header_label.setWordWrap(True)
        header_label.setStyleSheet("padding: 10px; background-color: #f5f5f5; border-radius: 4px;")
        layout.addWidget(header_label)
        
        # Tabbed content
        tab_widget = QTabWidget()
        
        # Field-by-field comparison tab
        if operation == 'UPDATE' and old_val and new_val:
            comparison_tab = self._create_field_comparison_tab(old_val, new_val)
            tab_widget.addTab(comparison_tab, "Field Changes")
        
        # Raw JSON tab
        json_tab = self._create_json_tab(old_val, new_val, operation)
        tab_widget.addTab(json_tab, "Raw Data")
        
        layout.addWidget(tab_widget)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        copy_btn = QPushButton("Copy JSON")
        copy_btn.clicked.connect(lambda: self._copy_version_data(old_val, new_val))
        
        rollback_btn = QPushButton(f"Rollback to Version {version}")
        rollback_btn.clicked.connect(lambda: self._rollback_to_version(version))
        rollback_btn.setStyleSheet("background-color: #ff9800; color: white; font-weight: bold;")
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        
        button_layout.addWidget(copy_btn)
        button_layout.addWidget(rollback_btn)
        button_layout.addStretch()
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        dialog.setLayout(layout)
        dialog.exec_()

    def _create_field_comparison_tab(self, old_val, new_val):
        """Create field-by-field comparison tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Create comparison table
        comparison_table = QTableWidget()
        comparison_table.setColumnCount(4)
        comparison_table.setHorizontalHeaderLabels(["Field", "Old Value", "New Value", "Change Type"])
        
        # Compare fields
        old_dict = old_val if isinstance(old_val, dict) else {}
        new_dict = new_val if isinstance(new_val, dict) else {}
        all_fields = sorted(set(old_dict.keys()) | set(new_dict.keys()))
        
        comparison_table.setRowCount(len(all_fields))
        
        for i, field in enumerate(all_fields):
            old_value = old_dict.get(field, '')
            new_value = new_dict.get(field, '')
            
            # Field name
            field_item = QTableWidgetItem(field)
            bold_font = QFont("Arial", 9)
            bold_font.setBold(True)
            field_item.setFont(bold_font)
            comparison_table.setItem(i, 0, field_item)
            
            # Old value
            old_item = QTableWidgetItem(str(old_value) if old_value is not None else '')
            if field not in old_dict:
                old_item.setText("(not present)")
                old_item.setForeground(QColor('#999'))
                italic_font = QFont("Arial", 8)
                italic_font.setItalic(True)
                old_item.setFont(italic_font)
            elif old_value != new_value:
                old_item.setBackground(QColor('#ffebee'))  # Light red for changed
            comparison_table.setItem(i, 1, old_item)
            
            # New value
            new_item = QTableWidgetItem(str(new_value) if new_value is not None else '')
            if field not in new_dict:
                new_item.setText("(not present)")
                new_item.setForeground(QColor('#999'))
                italic_font = QFont("Arial", 8)
                italic_font.setItalic(True)
                new_item.setFont(italic_font)
            elif old_value != new_value:
                new_item.setBackground(QColor('#e8f5e8'))  # Light green for changed
            comparison_table.setItem(i, 2, new_item)
            
            # Change type
            if field not in old_dict:
                change_type = "ADDED"
                change_color = QColor('#4caf50')  # Green
            elif field not in new_dict:
                change_type = "REMOVED"
                change_color = QColor('#f44336')  # Red
            elif old_value != new_value:
                change_type = "MODIFIED"
                change_color = QColor('#ff9800')  # Orange
            else:
                change_type = "UNCHANGED"
                change_color = QColor('#999')  # Gray
                
            change_item = QTableWidgetItem(change_type)
            change_item.setForeground(change_color)
            bold_font = QFont("Arial", 8)
            bold_font.setBold(True)
            change_item.setFont(bold_font)
            comparison_table.setItem(i, 3, change_item)
        
        comparison_table.resizeColumnsToContents()
        layout.addWidget(comparison_table)
        
        tab.setLayout(layout)
        return tab

    def _create_json_tab(self, old_val, new_val, operation):
        """Create raw JSON data tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        json_text = QTextEdit()
        json_text.setReadOnly(True)
        json_text.setFont(QFont("Courier", 9))
        
        content = f"OPERATION: {operation}\n\n"
        
        if operation in ['UPDATE', 'DELETE'] and old_val:
            content += "OLD VALUES:\n"
            content += json.dumps(old_val, indent=2, ensure_ascii=False)
            content += "\n\n"
        
        if operation in ['UPDATE', 'INSERT'] and new_val:
            content += "NEW VALUES:\n"
            content += json.dumps(new_val, indent=2, ensure_ascii=False)
        
        json_text.setPlainText(content)
        layout.addWidget(json_text)
        
        tab.setLayout(layout)
        return tab

    def compare_selected_versions(self):
        """Compare two selected versions"""
        try:
            selected_rows = set()
            for item in self.versioning_table.selectedItems():
                selected_rows.add(item.row())
            
            if len(selected_rows) != 2:
                QMessageBox.warning(self, "Selection Error", "Please select exactly 2 versions to compare.")
                return
            
            rows = sorted(list(selected_rows))
            version1_row, version2_row = rows
            
            # Get version numbers
            version1 = self.versioning_table.item(version1_row, 0).text()
            version2 = self.versioning_table.item(version2_row, 0).text()
            
            # Get data from database
            schema = self.version_schema_combo.currentText()
            table = self.version_table_combo.currentText()
            
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT version_number, old_val, new_val, tstamp, who, operation
                FROM {AUDIT_SCHEMA}.t_history
                WHERE schemaname = %s AND tabname = %s 
                AND version_number IN (%s, %s)
                ORDER BY version_number
            """, (schema, table, version1, version2))
            
            results = cursor.fetchall()
            cursor.close()
            
            if len(results) == 2:
                self._show_version_comparison_dialog(results, f"{schema}.{table}")
            else:
                QMessageBox.warning(self, "Error", "Could not retrieve version data for comparison.")
                
        except Exception as e:
            show_error_message(self, "Comparison Error", f"Error comparing versions: {e}")

    def _show_version_comparison_dialog(self, version_data, table_name):
        """Show version comparison dialog"""
        v1_data, v2_data = version_data
        v1_version, v1_old, v1_new, v1_time, v1_user, v1_op = v1_data
        v2_version, v2_old, v2_new, v2_time, v2_user, v2_op = v2_data
        
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Compare Versions {v1_version} ↔ {v2_version} - {table_name}")
        dialog.setMinimumSize(900, 700)
        
        layout = QVBoxLayout()
        
        # Comparison header
        header = f"""
        <table width="100%" style="background-color: #f0f0f0; padding: 10px;">
        <tr>
            <td width="50%"><b>Version {v1_version}</b><br>
            {format_timestamp(v1_time)}<br>
            User: {v1_user} | Operation: {v1_op}</td>
            <td width="50%"><b>Version {v2_version}</b><br>
            {format_timestamp(v2_time)}<br>
            User: {v2_user} | Operation: {v2_op}</td>
        </tr>
        </table>
        """
        
        header_label = QLabel(header)
        header_label.setWordWrap(True)
        layout.addWidget(header_label)
        
        # Side-by-side comparison table
        comparison_table = QTableWidget()
        comparison_table.setColumnCount(5)
        comparison_table.setHorizontalHeaderLabels([
            "Field", f"Version {v1_version}", f"Version {v2_version}", "Difference", "Change"
        ])
        
        # Get data for comparison (use new_val for each version)
        v1_data_dict = v1_new if v1_new else v1_old if v1_old else {}
        v2_data_dict = v2_new if v2_new else v2_old if v2_old else {}
        
        if not isinstance(v1_data_dict, dict):
            v1_data_dict = {}
        if not isinstance(v2_data_dict, dict):
            v2_data_dict = {}
        
        all_fields = sorted(set(v1_data_dict.keys()) | set(v2_data_dict.keys()))
        comparison_table.setRowCount(len(all_fields))
        
        for i, field in enumerate(all_fields):
            v1_value = v1_data_dict.get(field, '')
            v2_value = v2_data_dict.get(field, '')
            
            # Field name
            comparison_table.setItem(i, 0, QTableWidgetItem(field))
            
            # Version 1 value
            v1_item = QTableWidgetItem(str(v1_value) if v1_value is not None else '(empty)')
            comparison_table.setItem(i, 1, v1_item)
            
            # Version 2 value
            v2_item = QTableWidgetItem(str(v2_value) if v2_value is not None else '(empty)')
            comparison_table.setItem(i, 2, v2_item)
            
            # Difference and change type
            if v1_value != v2_value:
                if field not in v1_data_dict:
                    diff_text = "Field added"
                    change_type = "ADDED"
                    v1_item.setBackground(QColor('#f5f5f5'))
                    v2_item.setBackground(QColor('#e8f5e8'))
                elif field not in v2_data_dict:
                    diff_text = "Field removed"
                    change_type = "REMOVED"
                    v1_item.setBackground(QColor('#ffebee'))
                    v2_item.setBackground(QColor('#f5f5f5'))
                else:
                    diff_text = f"{v1_value} → {v2_value}"
                    change_type = "MODIFIED"
                    v1_item.setBackground(QColor('#fff3e0'))
                    v2_item.setBackground(QColor('#e3f2fd'))
            else:
                diff_text = "No change"
                change_type = "SAME"
                
            comparison_table.setItem(i, 3, QTableWidgetItem(diff_text))
            comparison_table.setItem(i, 4, QTableWidgetItem(change_type))
        
        comparison_table.resizeColumnsToContents()
        layout.addWidget(comparison_table)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)
        
        dialog.setLayout(layout)
        dialog.exec_()

    def export_version_history(self):
        """Export version history to CSV"""
        try:
            if self.versioning_table.rowCount() == 0:
                QMessageBox.warning(self, "No Data", "No version history to export.")
                return
            
            schema = self.version_schema_combo.currentText()
            table = self.version_table_combo.currentText()
            record_id = self.version_record_id_edit.text().strip()
            
            file_name = f"version_history_{schema}_{table}"
            if record_id:
                file_name += f"_record_{record_id}"
            file_name += f"_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            
            file_path, _ = QFileDialog.getSaveFileName(
                self, "Export Version History", file_name, "CSV Files (*.csv)"
            )
            
            if file_path:
                self._export_versioning_data(file_path, schema, table, record_id)
                
        except Exception as e:
            show_error_message(self, "Export Error", f"Error exporting version history: {e}")

    def _export_versioning_data(self, file_path, schema, table, record_id):
        """Export versioning data to CSV file"""
        with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile, delimiter=';')
            
            # Write metadata
            writer.writerow([f"# Version History Export - {schema}.{table}"])
            writer.writerow([f"# Export Date: {format_timestamp(datetime.now())}"])
            if record_id:
                writer.writerow([f"# Filtered for Record ID: {record_id}"])
            writer.writerow([f"# Total Versions: {self.versioning_table.rowCount()}"])
            writer.writerow([])
            
            # Write headers
            headers = []
            for col in range(self.versioning_table.columnCount() - 1):  # Exclude Actions column
                header_item = self.versioning_table.horizontalHeaderItem(col)
                headers.append(header_item.text() if header_item else f"Column {col}")
            writer.writerow(headers)
            
            # Write data
            for row in range(self.versioning_table.rowCount()):
                row_data = []
                for col in range(self.versioning_table.columnCount() - 1):  # Exclude Actions column
                    item = self.versioning_table.item(row, col)
                    row_data.append(item.text() if item else "")
                writer.writerow(row_data)
        
        show_info_message(self, "Export Complete", f"Version history exported to:\n{file_path}")

    def show_versioning_context_menu(self, position):
        """Show context menu for versioning table"""
        try:
            item = self.versioning_table.itemAt(position)
            if item is not None:
                menu = QMenu()
                
                current_row = self.versioning_table.currentRow()
                
                # Show details
                details_action = menu.addAction("Show Version Details")
                details_action.triggered.connect(lambda: self.show_version_details(current_row))
                
                # Copy record ID
                record_id_item = self.versioning_table.item(current_row, 5)
                if record_id_item:
                    copy_id_action = menu.addAction(f"Copy Record ID: {record_id_item.text()}")
                    copy_id_action.triggered.connect(lambda: self._copy_to_clipboard(record_id_item.text()))
                
                # Filter by this record ID
                if record_id_item and record_id_item.text() != 'N/A':
                    filter_action = menu.addAction(f"Filter by Record ID")
                    filter_action.triggered.connect(lambda: self._filter_by_record_id(record_id_item.text()))
                
                menu.addSeparator()
                
                # Rollback action
                version_item = self.versioning_table.item(current_row, 0)
                if version_item:
                    rollback_action = menu.addAction(f"Rollback to Version {version_item.text()}")
                    rollback_action.triggered.connect(lambda: self._rollback_to_version(version_item.text()))
                
                menu.exec_(self.versioning_table.mapToGlobal(position))
                
        except Exception as e:
            print(f"Error showing versioning context menu: {e}")

    def _filter_by_record_id(self, record_id):
        """Filter versioning by specific record ID"""
        self.version_record_id_edit.setText(record_id)
        self.load_table_history()

    def _rollback_to_version(self, version):
        """Rollback to specific version"""
        schema = self.version_schema_combo.currentText()
        table = self.version_table_combo.currentText()
        
        reply = show_question(
            self,
            "Confirm Rollback",
            f"Are you sure you want to rollback {schema}.{table} to version {version}?\n\n"
            f"This action will modify the current data!"
        )
        
        if reply == QMessageBox.Yes:
            try:
                cursor = self.db_connection.cursor()
                cursor.execute(f"""
                    SELECT {AUDIT_SCHEMA}.rollback_record_to_version(%s, %s, %s, %s)
                """, (schema, table, version, f"Rollback to version {version} via versioning tab"))
                
                result = cursor.fetchone()[0]
                self.db_connection.commit()
                cursor.close()
                
                if result:
                    show_info_message(self, "Success", f"Successfully rolled back to version {version}!")
                    # Refresh the history
                    self.load_table_history()
                else:
                    QMessageBox.warning(self, "Warning", "Rollback may not have completed successfully.")
                    
            except Exception as e:
                self.db_connection.rollback()
                show_error_message(self, "Rollback Error", f"Error during rollback: {e}")

    def _copy_version_data(self, old_val, new_val):
        """Copy version data to clipboard"""
        data = {
            "old_values": old_val,
            "new_values": new_val
        }
        json_text = json.dumps(data, indent=2, ensure_ascii=False)
        self._copy_to_clipboard(json_text)

    def toggle_diff_view(self, enabled):
        """Toggle between showing all changes or only differences"""
        # This is a placeholder for future enhancement
        # Could filter the table to show only rows with actual changes
        pass

    def load_versioning_tables(self, schema_name):
        """Populate the versioning table combo based on selected schema"""
        try:
            if not schema_name or not self.db_connection:
                return
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT DISTINCT tabname
                FROM {AUDIT_SCHEMA}.t_history
                WHERE schemaname = %s
                ORDER BY tabname
            """, (schema_name,))
            tables = [row[0] for row in cursor.fetchall()]
            cursor.close()
            self.version_table_combo.clear()
            self.version_table_combo.addItems(tables)
        except Exception as e:
            show_error_message(self, "Error", f"Failed to load tables: {e}")

    def populate_versioning_schemas(self):
        """Load schema names into versioning schema combo box"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute(f"SELECT DISTINCT schemaname FROM {AUDIT_SCHEMA}.t_history ORDER BY schemaname")
            schemas = [row[0] for row in cursor.fetchall()]
            cursor.close()
            self.version_schema_combo.clear()
            self.version_schema_combo.addItems(schemas)
            if schemas:
                self.load_versioning_tables(schemas[0])
        except Exception as e:
            show_error_message(self, "Error", f"Failed to load schemas: {e}")

    def setup_rollback_tab(self):
        """Rollback operations tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Rollback types
        rollback_tabs = QTabWidget()
        
        # Single record rollback
        single_tab = self._create_single_rollback_tab()
        
        # User changes rollback
        user_tab = self._create_user_rollback_tab()
        
        rollback_tabs.addTab(single_tab, "Single Record")
        rollback_tabs.addTab(user_tab, "User Changes")
        
        # Rollback history
        history_group = self._create_rollback_history_group()
        
        layout.addWidget(rollback_tabs)
        layout.addWidget(history_group)
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Rollback")

    def _create_single_rollback_tab(self):
        """Create single record rollback tab"""
        single_tab = QWidget()
        single_layout = QVBoxLayout()
        
        single_group = QGroupBox("Single Record Rollback")
        single_form = QGridLayout()
        
        single_form.addWidget(QLabel("Schema:"), 0, 0)
        self.rollback_schema = QComboBox()
        self.rollback_schema.addItems(DEFAULT_SCHEMAS)
        single_form.addWidget(self.rollback_schema, 0, 1)
        
        single_form.addWidget(QLabel("Table:"), 0, 2)
        self.rollback_table = QLineEdit()
        single_form.addWidget(self.rollback_table, 0, 3)
        
        single_form.addWidget(QLabel("Version:"), 1, 0)
        self.rollback_version = QSpinBox()
        self.rollback_version.setMinimum(1)
        self.rollback_version.setMaximum(9999)
        single_form.addWidget(self.rollback_version, 1, 1)
        
        single_form.addWidget(QLabel("Reason:"), 1, 2)
        self.rollback_reason = QLineEdit()
        self.rollback_reason.setPlaceholderText("Reason for rollback...")
        single_form.addWidget(self.rollback_reason, 1, 3)
        
        self.execute_single_rollback_btn = QPushButton("Execute Record Rollback")
        self.execute_single_rollback_btn.clicked.connect(self.execute_single_rollback)
        single_form.addWidget(self.execute_single_rollback_btn, 2, 0, 1, 4)
        
        single_group.setLayout(single_form)
        single_layout.addWidget(single_group)
        single_layout.addStretch()
        single_tab.setLayout(single_layout)
        
        return single_tab
        
    def _create_user_rollback_tab(self):
        """Create user changes rollback tab"""
        user_tab = QWidget()
        user_layout = QVBoxLayout()
        
        user_group = QGroupBox("Undo User Changes")
        user_form = QGridLayout()
        
        user_form.addWidget(QLabel("User:"), 0, 0)
        self.rollback_user = QComboBox()
        self.rollback_user.setEditable(True)
        user_form.addWidget(self.rollback_user, 0, 1)
        
        user_form.addWidget(QLabel("Minutes ago:"), 0, 2)
        self.rollback_minutes = QSpinBox()
        self.rollback_minutes.setMinimum(1)
        self.rollback_minutes.setMaximum(10080)  # 7 days
        self.rollback_minutes.setValue(60)
        user_form.addWidget(self.rollback_minutes, 0, 3)
        
        user_form.addWidget(QLabel("Reason:"), 1, 0)
        self.rollback_user_reason = QLineEdit()
        self.rollback_user_reason.setPlaceholderText("Reason for undoing changes...")
        user_form.addWidget(self.rollback_user_reason, 1, 1, 1, 3)
        
        # Test and execution buttons
        user_buttons = QHBoxLayout()
        self.test_user_rollback_btn = QPushButton("Test (Dry Run)")
        self.test_user_rollback_btn.clicked.connect(self.test_user_rollback)
        self.execute_user_rollback_btn = QPushButton("Execute User Rollback")
        self.execute_user_rollback_btn.clicked.connect(self.execute_user_rollback)
        
        user_buttons.addWidget(self.test_user_rollback_btn)
        user_buttons.addWidget(self.execute_user_rollback_btn)
        user_buttons.addStretch()
        
        user_form.addLayout(user_buttons, 2, 0, 1, 4)
        
        user_group.setLayout(user_form)
        
        # Rollback results area
        self.rollback_results = QTextEdit()
        self.rollback_results.setMaximumHeight(200)
        
        user_layout.addWidget(user_group)
        user_layout.addWidget(QLabel("Results:"))
        user_layout.addWidget(self.rollback_results)
        user_tab.setLayout(user_layout)
        
        return user_tab
        
    def _create_rollback_history_group(self):
        """Create rollback history group"""
        history_group = QGroupBox("Rollback History")
        history_layout = QVBoxLayout()
        
        self.rollback_history_table = QTableWidget()
        self.rollback_history_table.setColumnCount(6)
        self.rollback_history_table.setHorizontalHeaderLabels([
            "Date/Time", "User", "Table", "Reason", "Records Affected", "Success"
        ])
        
        history_layout.addWidget(self.rollback_history_table)
        history_group.setLayout(history_layout)
        
        return history_group
        
    def setup_stats_tab(self):
        """Statistics and reports tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Quick metrics
        metrics_layout = self._create_metrics_layout()
        
        # Statistics tables
        stats_tabs = self._create_stats_tabs()
        
        layout.addLayout(metrics_layout)
        layout.addWidget(stats_tabs)
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Statistics")
        
    def _create_metrics_layout(self):
        """Create metrics layout"""
        metrics_layout = QHBoxLayout()
        
        # Metric cards
        self.total_changes_label = QLabel("0")
        self.total_changes_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #2196F3;")
        self.active_users_label = QLabel("0")
        self.active_users_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #4CAF50;")
        self.tables_modified_label = QLabel("0")
        self.tables_modified_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #FF9800;")
        
        metrics_layout.addWidget(self._create_metric_card("Changes Today", self.total_changes_label))
        metrics_layout.addWidget(self._create_metric_card("Active Users", self.active_users_label))
        metrics_layout.addWidget(self._create_metric_card("Tables Modified", self.tables_modified_label))
        
        return metrics_layout
        
    def _create_stats_tabs(self):
        """Create statistics tabs"""
        stats_tabs = QTabWidget()
        
        # Top users
        self.top_users_table = QTableWidget()
        self.top_users_table.setColumnCount(5)
        self.top_users_table.setHorizontalHeaderLabels([
            "User", "Changes", "Inserts", "Updates", "Deletions"
        ])
        stats_tabs.addTab(self.top_users_table, "Top Users")
        
        # Top tables
        self.top_tables_table = QTableWidget()
        self.top_tables_table.setColumnCount(4)
        self.top_tables_table.setHorizontalHeaderLabels([
            "Table", "Changes", "Users Involved", "Last Modified"
        ])
        stats_tabs.addTab(self.top_tables_table, "Top Tables")
        
        # Hourly activity
        self.hourly_activity_table = QTableWidget()
        self.hourly_activity_table.setColumnCount(2)
        self.hourly_activity_table.setHorizontalHeaderLabels([
            "Hour", "Changes"
        ])
        stats_tabs.addTab(self.hourly_activity_table, "Hourly Activity")
        
        return stats_tabs
        
    def setup_config_tab(self):
        """Configuration tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # Database configuration
        db_group = self._create_db_config_group()
        
        # Refresh options
        refresh_group = self._create_refresh_options_group()
        
        # System info
        info_group = self._create_system_info_group()
        
        layout.addWidget(db_group)
        layout.addWidget(refresh_group)
        layout.addWidget(info_group)
        layout.addStretch()
        
        tab.setLayout(layout)
        self.tab_widget.addTab(tab, "Configuration")
        
    def _create_db_config_group(self):
        """Create database configuration group"""
        db_group = QGroupBox("Database Configuration")
        db_layout = QGridLayout()
        
        # Database fields
        fields = [
            ("Host:", "db_host_edit"),
            ("Port:", "db_port_edit"),
            ("Database:", "db_name_edit"),
            ("User:", "db_user_edit")
        ]
        
        for i, (label, attr_name) in enumerate(fields):
            row = i // 2 if i < 2 else i - 1
            col = (i % 2) * 2 if i < 2 else 0
            col_span = 1 if i < 2 else 3
            
            db_layout.addWidget(QLabel(label), row, col)
            
            edit = QLineEdit()
            edit.setReadOnly(True)
            setattr(self, attr_name, edit)
            db_layout.addWidget(edit, row, col + 1, 1, col_span)
        
        # Connection status
        db_layout.addWidget(QLabel("Status:"), 2, 0)
        self.connection_status = QLabel("Connected")
        self.connection_status.setStyleSheet("color: green; font-weight: bold;")
        db_layout.addWidget(self.connection_status, 2, 1)
        
        # Configuration buttons
        config_buttons = QHBoxLayout()
        self.change_connection_btn = QPushButton("Change Connection")
        self.change_connection_btn.clicked.connect(self.change_database_connection)
        self.test_connection_btn = QPushButton("Test Connection")
        self.test_connection_btn.clicked.connect(self.test_current_connection)
        
        config_buttons.addWidget(self.change_connection_btn)
        config_buttons.addWidget(self.test_connection_btn)
        config_buttons.addStretch()
        
        db_layout.addLayout(config_buttons, 3, 0, 1, 4)
        
        # Audit System Setup Button
        self.setup_audit_btn = QPushButton("Setup Audit System")
        self.setup_audit_btn.clicked.connect(self.open_audit_setup)
        db_layout.addWidget(self.setup_audit_btn, 4, 0, 1, 2)
        
        db_group.setLayout(db_layout)
        
        # Load current database settings
        self.load_db_config_display()
        
        return db_group
        
    def _create_refresh_options_group(self):
        """Create refresh options group"""
        refresh_group = QGroupBox("Refresh Options")
        refresh_layout = QVBoxLayout()
        
        self.auto_refresh_interval = QSpinBox()
        self.auto_refresh_interval.setMinimum(10)
        self.auto_refresh_interval.setMaximum(300)
        self.auto_refresh_interval.setValue(DEFAULT_REFRESH_INTERVAL)
        self.auto_refresh_interval.setSuffix(" seconds")
        
        refresh_layout.addWidget(QLabel("Auto-refresh interval:"))
        refresh_layout.addWidget(self.auto_refresh_interval)
        
        refresh_group.setLayout(refresh_layout)
        return refresh_group
        
    def _create_system_info_group(self):
        """Create system info group"""
        info_group = QGroupBox("System Information")
        info_layout = QVBoxLayout()
        
        self.system_info_text = QTextEdit()
        self.system_info_text.setMaximumHeight(150)
        self.system_info_text.setReadOnly(True)
        
        info_layout.addWidget(self.system_info_text)
        info_group.setLayout(info_layout)
        
        return info_group
        
    def _create_metric_card(self, title, value_label):
        """Create a metric card widget"""
        card = QGroupBox(title)
        layout = QVBoxLayout()
        layout.addWidget(value_label)
        card.setLayout(layout)
        card.setMaximumHeight(80)
        return card
        
    def load_db_config_display(self):
        """Load current database configuration for display"""
        try:
            if self.manager and self.manager.db_params:
                params = self.manager.db_params
                self.db_host_edit.setText(params.get('host', ''))
                self.db_port_edit.setText(params.get('port', ''))
                self.db_name_edit.setText(params.get('database', ''))
                self.db_user_edit.setText(params.get('user', ''))
        except Exception as e:
            print(f"Error loading DB config display: {e}")
            
    def change_database_connection(self):
        """Open dialog to change database connection"""
        try:
            config_dialog = DatabaseConfigDialog(self.manager, self)
            if config_dialog.exec_() == QDialog.Accepted:
                try:
                    # Test new connection
                    self.manager.connect_database()
                    
                    # Update display
                    self.load_db_config_display()
                    self.connection_status.setText("Connected")
                    self.connection_status.setStyleSheet("color: green; font-weight: bold;")
                    
                    # Update database connection
                    if self.db_connection:
                        self.db_connection.close()
                    self.db_connection = self.manager.db_connection
                    
                    # Refresh all data with new connection
                    self.refresh_all_data()
                    
                    show_info_message(self, "Success", "Database connection updated successfully!")
                    
                except Exception as e:
                    self.connection_status.setText("Connection Failed")
                    self.connection_status.setStyleSheet("color: red; font-weight: bold;")
                    show_error_message(self, "Connection Error", 
                                     f"Failed to connect with new settings:\n{str(e)}")
        except Exception as e:
            show_error_message(self, "Error", f"Error opening connection dialog: {str(e)}")
                
    def test_current_connection(self):
        """Test current database connection"""
        try:
            if self.db_connection and not self.db_connection.closed:
                cursor = self.db_connection.cursor()
                cursor.execute("SELECT version();")
                version = cursor.fetchone()[0]
                cursor.close()
                
                self.connection_status.setText("Connected")
                self.connection_status.setStyleSheet("color: green; font-weight: bold;")
                show_info_message(self, "Connection Test", 
                                f"Connection successful!\n\nPostgreSQL Version:\n{version[:100]}...")
            else:
                raise Exception("No active connection")
                
        except Exception as e:
            self.connection_status.setText("Connection Failed")
            self.connection_status.setStyleSheet("color: red; font-weight: bold;")
            show_error_message(self, "Connection Test", f"Connection test failed:\n{str(e)}")
            
    # =====================================================
    # DATA LOADING METHODS
    # =====================================================
    
    def load_recent_changes(self):
        """Load recent changes with enhanced filtering and smart search support"""
        try:
            if not self.ui_initialized or not self.db_connection or self.db_connection.closed:
                return
                
            cursor = self.db_connection.cursor()
            
            # Build query with enhanced filters
            where_conditions = [f"tstamp >= NOW() - INTERVAL '1 hour'"]
            
            # User filter
            if hasattr(self, 'user_filter') and self.user_filter and self.user_filter.currentText() != "All users":
                where_conditions.append(f"who = '{self.user_filter.currentText()}'")
                
            # Schema filter
            if hasattr(self, 'schema_filter') and self.schema_filter and self.schema_filter.currentText() != "All schemas":
                where_conditions.append(f"schemaname = '{self.schema_filter.currentText()}'")
                
            # NEW: Table filter 🎯
            if hasattr(self, 'table_filter') and self.table_filter and self.table_filter.currentText() != "All tables":
                where_conditions.append(f"tabname = '{self.table_filter.currentText()}'")
                
            # Time interval
            interval = "1 hour"  # Default
            if hasattr(self, 'time_filter') and self.time_filter:
                interval = TIME_INTERVALS.get(self.time_filter.currentText(), "1 hour")
            where_conditions[0] = f"tstamp >= NOW() - INTERVAL '{interval}'"
            
            # Enhanced query with better ID detection
            query = self._build_changes_query(where_conditions)
            
            cursor.execute(query)
            rows = cursor.fetchall()
            
            # Populate table
            self._populate_recent_changes_table(rows)
            
            cursor.close()
            
            # Update status with filter info
            self._update_filter_status(len(rows))
            
        except Exception as e:
            print(f"Error loading changes: {e}")
            
    def _update_filter_status(self, row_count):
        """Update status label with current filter information"""
        try:
            filters_active = []
            
            if hasattr(self, 'user_filter') and self.user_filter.currentText() != "All users":
                filters_active.append(f"User: {self.user_filter.currentText()}")
                
            if hasattr(self, 'schema_filter') and self.schema_filter.currentText() != "All schemas":
                filters_active.append(f"Schema: {self.schema_filter.currentText()}")
                
            if hasattr(self, 'table_filter') and self.table_filter.currentText() != "All tables":
                filters_active.append(f"Table: {self.table_filter.currentText()}")
                
            if hasattr(self, 'time_filter'):
                filters_active.append(f"Period: {self.time_filter.currentText()}")
                
            if filters_active:
                filter_text = " | ".join(filters_active)
                self.status_label.setText(f"📊 {row_count} records ({filter_text})")
            else:
                self.status_label.setText(f"📊 {row_count} records loaded")
                
        except Exception as e:
            print(f"Error updating filter status: {e}")
            self.status_label.setText(f"📊 {row_count} records loaded")
            
    def _build_changes_query(self, where_conditions):
        """Build enhanced query for recent changes with improved ID detection"""
        # Enhanced ID extraction logic with multiple fallbacks
        id_extraction = """
        COALESCE(
            -- Try common ID fields first (exact matches)
            CASE WHEN h.new_val->>'id' IS NOT NULL AND h.new_val->>'id' != '' THEN h.new_val->>'id' ELSE h.old_val->>'id' END,
            CASE WHEN h.new_val->>'gid' IS NOT NULL AND h.new_val->>'gid' != '' THEN h.new_val->>'gid' ELSE h.old_val->>'gid' END,
            CASE WHEN h.new_val->>'fid' IS NOT NULL AND h.new_val->>'fid' != '' THEN h.new_val->>'fid' ELSE h.old_val->>'fid' END,
            CASE WHEN h.new_val->>'objectid' IS NOT NULL AND h.new_val->>'objectid' != '' THEN h.new_val->>'objectid' ELSE h.old_val->>'objectid' END,
            CASE WHEN h.new_val->>'oid' IS NOT NULL AND h.new_val->>'oid' != '' THEN h.new_val->>'oid' ELSE h.old_val->>'oid' END,
            CASE WHEN h.new_val->>'pk' IS NOT NULL AND h.new_val->>'pk' != '' THEN h.new_val->>'pk' ELSE h.old_val->>'pk' END,
            CASE WHEN h.new_val->>'_id' IS NOT NULL AND h.new_val->>'_id' != '' THEN h.new_val->>'_id' ELSE h.old_val->>'_id' END,
            -- Try fields ending with 'id' (case insensitive)
            (SELECT COALESCE(h.new_val->>key, h.old_val->>key)
             FROM json_each(COALESCE(h.new_val, h.old_val)) 
             WHERE key ILIKE '%id' 
             AND COALESCE(h.new_val->>key, h.old_val->>key) IS NOT NULL 
             AND COALESCE(h.new_val->>key, h.old_val->>key) != ''
             AND COALESCE(h.new_val->>key, h.old_val->>key) ~ '^[0-9]+'
             ORDER BY 
                CASE 
                    WHEN key = 'id' THEN 1
                    WHEN key = 'gid' THEN 2  
                    WHEN key = 'fid' THEN 3
                    WHEN key = 'objectid' THEN 4
                    WHEN key ILIKE '%_id' THEN 5
                    WHEN key ILIKE '%id' THEN 6
                    ELSE 7
                END
             LIMIT 1),
            -- Try numeric fields as potential IDs
            (SELECT COALESCE(h.new_val->>key, h.old_val->>key)
             FROM json_each(COALESCE(h.new_val, h.old_val)) 
             WHERE COALESCE(h.new_val->>key, h.old_val->>key) ~ '^[0-9]+'
             AND COALESCE(h.new_val->>key, h.old_val->>key) IS NOT NULL
             AND COALESCE(h.new_val->>key, h.old_val->>key) != ''
             ORDER BY key
             LIMIT 1),
            -- Last resort: use first non-null field
            (SELECT COALESCE(h.new_val->>key, h.old_val->>key)
             FROM json_each(COALESCE(h.new_val, h.old_val)) 
             WHERE COALESCE(h.new_val->>key, h.old_val->>key) IS NOT NULL
             AND COALESCE(h.new_val->>key, h.old_val->>key) != ''
             ORDER BY key
             LIMIT 1),
            '[No ID Found]'
        )
        """
        
        return f"""
            SELECT 
                h.tstamp,
                h.who,
                h.schemaname||'.'||h.tabname as table_name,
                h.operation,
                {id_extraction} as record_id,
                COALESCE(h.change_reason, '-') as reason,
                COALESCE(h.version_number::text, '-') as version,
                -- Debug info for available keys
                CASE 
                    WHEN h.operation = 'DELETE' THEN 
                        (SELECT string_agg(key, ', ' ORDER BY key) FROM json_object_keys(h.old_val) key LIMIT 10)
                    ELSE 
                        (SELECT string_agg(key, ', ' ORDER BY key) FROM json_object_keys(h.new_val) key LIMIT 10)
                END as debug_keys
            FROM {AUDIT_SCHEMA}.t_history h
            WHERE {' AND '.join(where_conditions)}
            ORDER BY h.tstamp DESC
            LIMIT {MAX_ROWS_DISPLAY}
        """
        
    def _populate_recent_changes_table(self, rows):
        """Populate recent changes table with data"""
        if not hasattr(self, 'recent_changes_table') or not self.recent_changes_table:
            return
            
        self.recent_changes_table.setRowCount(len(rows))
        for i, row in enumerate(rows):
            for j, value in enumerate(row):
                if j == 0:  # Timestamp
                    value = format_timestamp(value)
                elif j == 7:  # Debug keys column
                    item = QTableWidgetItem(str(value)[:50] + "..." if value and len(str(value)) > 50 else str(value))
                    item.setToolTip(f"Available keys in JSON: {value}")
                    self.recent_changes_table.setItem(i, j, item)
                    continue
                elif j == 4:  # Record ID column - enhanced formatting
                    item = QTableWidgetItem(str(value))
                    bold_font = QFont("Arial", 9)
                    bold_font.setBold(True)
                    item.setFont(bold_font)
                    
                    if str(value).startswith('AUTO_'):
                        # Auto-generated ID
                        item.setBackground(QColor('#fff3e0'))  # Light orange
                        item.setToolTip("🔧 Auto-generated ID: Table has no standard primary key")
                    elif str(value) not in ['N/A', '[No ID Found]', '[Multiple Fields]']:
                        # Natural ID
                        item.setBackground(QColor('#e8f5e8'))  # Light green  
                        item.setToolTip("✅ Natural ID: Found in table's primary key field")
                    else:
                        # No ID found
                        item.setBackground(QColor('#ffebee'))  # Light red
                        item.setToolTip("❌ No usable ID found")
                        
                    self.recent_changes_table.setItem(i, j, item)
                    continue
                    
                self.recent_changes_table.setItem(i, j, QTableWidgetItem(str(value)))
                
        # Color rows by operation type
        self._color_rows_by_operation(len(rows))
        
    def _color_rows_by_operation(self, row_count):
        """Color table rows based on operation type"""
        operation_colors = {
            'INSERT': QColor('#E8F5E8'),  # Light green
            'UPDATE': QColor('#FFF3E0'),  # Light orange
            'DELETE': QColor('#FFEBEE'),  # Light red
        }
        
        for i in range(row_count):
            if self.recent_changes_table.item(i, 3):
                operation = self.recent_changes_table.item(i, 3).text()
                color = operation_colors.get(operation, QColor('#F5F5F5'))  # Light gray default
                
                for j in range(8):
                    item = self.recent_changes_table.item(i, j)
                    if item:
                        item.setBackground(color)
            
    def load_statistics(self):
        """Load statistics with error handling"""
        try:
            if not self.ui_initialized or not self.db_connection or self.db_connection.closed:
                return
                
            cursor = self.db_connection.cursor()
            
            # Today's metrics
            cursor.execute(f"""
                SELECT 
                    COUNT(*) as changes_today,
                    COUNT(DISTINCT who) as active_users,
                    COUNT(DISTINCT schemaname||'.'||tabname) as tables_modified
                FROM {AUDIT_SCHEMA}.t_history 
                WHERE tstamp >= CURRENT_DATE
            """)
            
            stats = cursor.fetchone()
            if stats and hasattr(self, 'total_changes_label'):
                self.total_changes_label.setText(str(stats[0]))
                self.active_users_label.setText(str(stats[1]))
                self.tables_modified_label.setText(str(stats[2]))
            
            # Load additional statistics
            self._load_top_users_stats(cursor)
            self._load_top_tables_stats(cursor)
            
            cursor.close()
            
        except Exception as e:
            print(f"Error loading statistics: {e}")
            
    def _load_top_users_stats(self, cursor):
        """Load top users statistics"""
        cursor.execute(f"""
            SELECT 
                who,
                COUNT(*) as total,
                COUNT(CASE WHEN operation = 'INSERT' THEN 1 END) as inserts,
                COUNT(CASE WHEN operation = 'UPDATE' THEN 1 END) as updates,
                COUNT(CASE WHEN operation = 'DELETE' THEN 1 END) as deletions
            FROM {AUDIT_SCHEMA}.t_history 
            WHERE tstamp >= CURRENT_DATE - INTERVAL '7 days'
            GROUP BY who
            ORDER BY total DESC
            LIMIT 20
        """)
        
        users_data = cursor.fetchall()
        if hasattr(self, 'top_users_table'):
            self.top_users_table.setRowCount(len(users_data))
            for i, row in enumerate(users_data):
                for j, value in enumerate(row):
                    self.top_users_table.setItem(i, j, QTableWidgetItem(str(value)))
                    
    def _load_top_tables_stats(self, cursor):
        """Load top tables statistics"""
        cursor.execute(f"""
            SELECT 
                schemaname||'.'||tabname as table_name,
                COUNT(*) as changes,
                COUNT(DISTINCT who) as users,
                MAX(tstamp) as last_modified
            FROM {AUDIT_SCHEMA}.t_history 
            WHERE tstamp >= CURRENT_DATE - INTERVAL '7 days'
            GROUP BY schemaname, tabname
            ORDER BY changes DESC
            LIMIT 20
        """)
        
        tables_data = cursor.fetchall()
        if hasattr(self, 'top_tables_table'):
            self.top_tables_table.setRowCount(len(tables_data))
            for i, row in enumerate(tables_data):
                for j, value in enumerate(row):
                    if j == 3:  # Last modified
                        value = format_timestamp(value)
                    self.top_tables_table.setItem(i, j, QTableWidgetItem(str(value)))
                    
    def load_rollback_history(self):
        """Load rollback history with error handling"""
        try:
            if not self.ui_initialized or not self.db_connection or self.db_connection.closed:
                return
                
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT 
                    rollback_timestamp,
                    rollback_user,
                    target_schema||'.'||target_table,
                    rollback_reason,
                    records_affected,
                    CASE WHEN success THEN 'Yes' ELSE 'No' END
                FROM {AUDIT_SCHEMA}.t_rollback_history 
                ORDER BY rollback_timestamp DESC
                LIMIT 100
            """)
            
            rows = cursor.fetchall()
            if hasattr(self, 'rollback_history_table'):
                self.rollback_history_table.setRowCount(len(rows))
                for i, row in enumerate(rows):
                    for j, value in enumerate(row):
                        if j == 0:  # Timestamp
                            value = format_timestamp(value)
                        self.rollback_history_table.setItem(i, j, QTableWidgetItem(str(value)))
                        
            cursor.close()
            
        except Exception as e:
            print(f"Error loading rollback history: {e}")
            
    def load_system_info(self):
        """Load system info with error handling"""
        try:
            if not self.ui_initialized or not self.db_connection or self.db_connection.closed:
                return
                
            cursor = self.db_connection.cursor()
            
            # Database info
            cursor.execute("SELECT version()")
            pg_version = cursor.fetchone()[0]
            
            # Trigger count
            cursor.execute(f"""
                SELECT 
                    n.nspname,
                    COUNT(DISTINCT c.relname)
                FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                WHERE t.tgname = %s
                    AND n.nspname = ANY(%s)
                GROUP BY n.nspname
                ORDER BY n.nspname
            """, (TRIGGER_NAME, DEFAULT_SCHEMAS))
            
            triggers_info = cursor.fetchall()
            
            # Log table size
            cursor.execute(f"""
                SELECT pg_size_pretty(pg_total_relation_size('{AUDIT_SCHEMA}.t_history'))
            """)
            
            log_size = cursor.fetchone()[0]
            
            info_text = f"""PostgreSQL: {pg_version[:50]}...

Monitored Tables:
{chr(10).join([f"- {schema}: {count} tables" for schema, count in triggers_info])}

Log Size: {log_size}

ID Detection System:
- Natural IDs: Found in primary key fields (green in tables)
- Auto-generated IDs: Hash-based for tables without PKs (orange in tables)  
- Supports: id, gid, fid, objectid, oid, pk, _id and custom fields

System Information:
- Plugin Version: 1.0.0
- Qt Version: {getattr(self.manager, 'qt_version', 'Unknown') if hasattr(self, 'manager') else 'Unknown'}
- QGIS Version: {QgsProject.instance().readEntry('qgis', 'version', '')[0] if QgsProject.instance() else 'Unknown'}

Last Update: {format_timestamp(datetime.now())}
            """
            
            if hasattr(self, 'system_info_text'):
                self.system_info_text.setPlainText(info_text)
            cursor.close()
            
        except Exception as e:
            if hasattr(self, 'system_info_text'):
                self.system_info_text.setPlainText(f"Error loading system info: {e}")

    # =====================================================
    # ROLLBACK METHODS
    # =====================================================
    
    def execute_single_rollback(self):
        """Execute single record rollback"""
        try:
            schema = self.rollback_schema.currentText()
            table = self.rollback_table.text()
            version = self.rollback_version.value()
            reason = self.rollback_reason.text()
            
            if not table:
                QMessageBox.warning(self, "Error", "Please enter table name")
                return
                
            if not reason:
                reason = "Manual rollback via plugin"
                
            # Confirm rollback
            reply = show_question(
                self,
                "Confirm Rollback",
                f"Are you sure you want to rollback {schema}.{table} to version {version}?\n\n"
                f"Reason: {reason}"
            )
            
            if reply != QMessageBox.Yes:
                return
                
            # Execute rollback
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT {AUDIT_SCHEMA}.rollback_record_to_version(%s, %s, %s, %s)
            """, (schema, table, version, reason))
            
            result = cursor.fetchone()[0]
            self.db_connection.commit()
            cursor.close()
            
            if result:
                show_info_message(self, "Success", "Rollback executed successfully!")
                self.load_rollback_history()
            else:
                QMessageBox.warning(self, "Warning", "Rollback may not have completed successfully")
                
        except Exception as e:
            self.db_connection.rollback()
            show_error_message(self, "Rollback Error", f"Error executing rollback: {str(e)}")
            
    def test_user_rollback(self):
        """Test user rollback (dry run)"""
        try:
            user = self.rollback_user.currentText()
            minutes = self.rollback_minutes.value()
            reason = self.rollback_user_reason.text() or "Test undo user changes"
            
            if not user:
                QMessageBox.warning(self, "Error", "Please select a user")
                return
                
            # Execute dry run
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT {AUDIT_SCHEMA}.undo_user_changes(%s, %s, %s, %s)
            """, (user, minutes, reason, True))  # True for dry run
            
            result = cursor.fetchone()[0]
            cursor.close()
            
            self.rollback_results.setPlainText(result)
            
        except Exception as e:
            self.rollback_results.setPlainText(f"Error testing rollback: {str(e)}")
            
    def execute_user_rollback(self):
        """Execute user rollback"""
        try:
            user = self.rollback_user.currentText()
            minutes = self.rollback_minutes.value()
            reason = self.rollback_user_reason.text() or "Undo user changes via plugin"
            
            if not user:
                QMessageBox.warning(self, "Error", "Please select a user")
                return
                
            # Confirm rollback
            reply = show_question(
                self,
                "Confirm User Rollback",
                f"Are you sure you want to undo all changes by '{user}' from the last {minutes} minutes?\n\n"
                f"Reason: {reason}\n\n"
                f"This operation cannot be easily undone!"
            )
            
            if reply != QMessageBox.Yes:
                return
                
            # Execute rollback
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT {AUDIT_SCHEMA}.undo_user_changes(%s, %s, %s, %s)
            """, (user, minutes, reason, False))  # False for actual execution
            
            result = cursor.fetchone()[0]
            self.db_connection.commit()
            cursor.close()
            
            self.rollback_results.setPlainText(result)
            
            # Refresh data
            self.load_rollback_history()
            self.load_recent_changes()
            
            show_info_message(self, "Success", "User rollback executed successfully!")
            
        except Exception as e:
            self.db_connection.rollback()
            self.rollback_results.setPlainText(f"Error executing rollback: {str(e)}")
            show_error_message(self, "Rollback Error", f"Error executing user rollback: {str(e)}")

    # =====================================================
    # ENHANCED FEATURES METHODS
    # =====================================================
    
    def setup_real_time_monitoring(self):
        """Setup real-time monitoring capabilities"""
        try:
            # Create a timer for real-time updates
            self.real_time_timer = QTimer()
            self.real_time_timer.timeout.connect(self._update_real_time_stats)
            
        except Exception as e:
            print(f"Error setting up real-time monitoring: {e}")

    def _update_real_time_stats(self):
        """Update real-time statistics"""
        try:
            if not self.db_connection or self.db_connection.closed:
                return
                
            # Quick update of key metrics without full refresh
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT COUNT(*) FROM {AUDIT_SCHEMA}.t_history 
                WHERE tstamp >= NOW() - INTERVAL '1 minute'
            """)
            
            recent_count = cursor.fetchone()[0]
            
            if recent_count > 0 and hasattr(self, 'status_label'):
                self.status_label.setText(f"Real-time: {recent_count} changes in last minute")
                # Auto-refresh recent changes if there are new ones
                self.load_recent_changes()
                
            cursor.close()
            
        except Exception as e:
            print(f"Error in real-time update: {e}")

    def setup_advanced_search(self):
        """Setup advanced search capabilities"""
        try:
            # Add advanced search tab if not exists
            if hasattr(self, 'tab_widget'):
                search_tab = QWidget()
                search_layout = QVBoxLayout()
                
                # Advanced search form
                search_group = QGroupBox("Advanced Search")
                search_form = QGridLayout()
                
                # Search criteria
                search_form.addWidget(QLabel("Schema:"), 0, 0)
                self.search_schema = QComboBox()
                self.search_schema.addItems(["All"] + DEFAULT_SCHEMAS)
                search_form.addWidget(self.search_schema, 0, 1)
                
                search_form.addWidget(QLabel("Table:"), 0, 2)
                self.search_table = QLineEdit()
                search_form.addWidget(self.search_table, 0, 3)
                
                search_form.addWidget(QLabel("User:"), 1, 0)
                self.search_user = QLineEdit()
                search_form.addWidget(self.search_user, 1, 1)
                
                search_form.addWidget(QLabel("Operation:"), 1, 2)
                self.search_operation = QComboBox()
                self.search_operation.addItems(["All", "INSERT", "UPDATE", "DELETE"])
                search_form.addWidget(self.search_operation, 1, 3)
                
                search_form.addWidget(QLabel("From Date:"), 2, 0)
                self.search_from_date = QDateTimeEdit()
                self.search_from_date.setDateTime(datetime.now() - timedelta(days=7))
                search_form.addWidget(self.search_from_date, 2, 1)
                
                search_form.addWidget(QLabel("To Date:"), 2, 2)
                self.search_to_date = QDateTimeEdit()
                self.search_to_date.setDateTime(datetime.now())
                search_form.addWidget(self.search_to_date, 2, 3)
                
                # Search button
                self.execute_search_btn = QPushButton("Execute Search")
                self.execute_search_btn.clicked.connect(self.execute_advanced_search)
                search_form.addWidget(self.execute_search_btn, 3, 0, 1, 4)
                
                search_group.setLayout(search_form)
                
                # Results table
                self.search_results_table = QTableWidget()
                self.search_results_table.setColumnCount(8)
                self.search_results_table.setHorizontalHeaderLabels([
                    "Date/Time", "User", "Table", "Action", "Record ID", "Reason", "Version", "Details"
                ])
                
                search_layout.addWidget(search_group)
                search_layout.addWidget(self.search_results_table)
                
                search_tab.setLayout(search_layout)
                self.tab_widget.addTab(search_tab, "Advanced Search")
                
        except Exception as e:
            print(f"Error setting up advanced search: {e}")

    def execute_advanced_search(self):
        """Execute enhanced advanced search"""
        try:
            if not self.db_connection or self.db_connection.closed:
                QMessageBox.warning(self, "Connection Error", "No database connection available.")
                return
                
            # Build search query based on criteria
            where_conditions = []
            params = []
            
            # Schema filter
            if hasattr(self, 'search_schema') and self.search_schema.currentText() != "All":
                where_conditions.append("h.schemaname = %s")
                params.append(self.search_schema.currentText())
                
            # Table filter
            if hasattr(self, 'search_table') and self.search_table.text():
                where_conditions.append("h.tabname ILIKE %s")
                params.append(f"%{self.search_table.text()}%")
                
            # User filter
            if hasattr(self, 'search_user') and self.search_user.text():
                where_conditions.append("h.who ILIKE %s")
                params.append(f"%{self.search_user.text()}%")
                
            # Operation filter
            if hasattr(self, 'search_operation') and self.search_operation.currentText() != "All":
                where_conditions.append("h.operation = %s")
                params.append(self.search_operation.currentText())
                
            # Date range
            if hasattr(self, 'search_from_date'):
                where_conditions.append("h.tstamp >= %s")
                params.append(self.search_from_date.dateTime().toPython())
                
            if hasattr(self, 'search_to_date'):
                where_conditions.append("h.tstamp <= %s")
                params.append(self.search_to_date.dateTime().toPython())
            
            # Build final query with enhanced ID extraction
            base_where = ' AND '.join(where_conditions) if where_conditions else '1=1'
            
            query = f"""
                SELECT 
                    h.tstamp,
                    h.who,
                    h.schemaname||'.'||h.tabname as table_name,
                    h.operation,
                    COALESCE(
                        -- Enhanced ID extraction for search results
                        CASE WHEN h.new_val->>'id' IS NOT NULL AND h.new_val->>'id' != '' THEN h.new_val->>'id' ELSE h.old_val->>'id' END,
                        CASE WHEN h.new_val->>'gid' IS NOT NULL AND h.new_val->>'gid' != '' THEN h.new_val->>'gid' ELSE h.old_val->>'gid' END,
                        CASE WHEN h.new_val->>'fid' IS NOT NULL AND h.new_val->>'fid' != '' THEN h.new_val->>'fid' ELSE h.old_val->>'fid' END,
                        CASE WHEN h.new_val->>'objectid' IS NOT NULL AND h.new_val->>'objectid' != '' THEN h.new_val->>'objectid' ELSE h.old_val->>'objectid' END,
                        (SELECT COALESCE(h.new_val->>key, h.old_val->>key)
                         FROM json_each(COALESCE(h.new_val, h.old_val)) 
                         WHERE key ILIKE '%id' 
                         AND COALESCE(h.new_val->>key, h.old_val->>key) IS NOT NULL 
                         AND COALESCE(h.new_val->>key, h.old_val->>key) != ''
                         ORDER BY 
                            CASE 
                                WHEN key = 'id' THEN 1
                                WHEN key = 'gid' THEN 2  
                                WHEN key = 'fid' THEN 3
                                ELSE 4
                            END
                         LIMIT 1),
                        -- Generate hash-based ID when no natural ID exists
                        'AUTO_' || substr(md5(COALESCE(h.new_val::text, h.old_val::text)), 1, 8)
                    ) as record_id,
                    COALESCE(h.change_reason, '-') as reason,
                    COALESCE(h.version_number::text, '-') as version,
                    'View Details'
                FROM {AUDIT_SCHEMA}.t_history h
                WHERE {base_where}
                ORDER BY h.tstamp DESC
                LIMIT 1000
            """
            
            # Execute search
            cursor = self.db_connection.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()
            cursor.close()
            
            # Populate results table with enhanced formatting
            self.search_results_table.setRowCount(len(rows))
            for i, row in enumerate(rows):
                for j, value in enumerate(row):
                    if j == 0:  # Timestamp
                        value = format_timestamp(value)
                    
                    item = QTableWidgetItem(str(value))
                    
                    # Color-code by operation
                    if j == 3:  # Operation column
                        if value == 'INSERT':
                            item.setBackground(QColor('#E8F5E8'))
                        elif value == 'UPDATE':
                            item.setBackground(QColor('#FFF3E0'))
                        elif value == 'DELETE':
                            item.setBackground(QColor('#FFEBEE'))
                    
                    # Make Record ID column bold and copyable with visual distinction
                    if j == 4:  # Record ID column
                        bold_font = QFont("Arial", 9)
                        bold_font.setBold(True)
                        item.setFont(bold_font)
                        if str(value).startswith('AUTO_'):
                            # Auto-generated ID - orange background
                            item.setBackground(QColor('#fff3e0'))
                            item.setToolTip("Auto-generated ID: Created for tables without primary keys")
                        elif value not in ['[Multiple Fields]', 'N/A', '[No ID Found]']:
                            # Natural ID - blue background
                            item.setBackground(QColor('#e3f2fd'))
                            item.setToolTip("Natural ID: Found in table's primary key field")
                        else:
                            # Other cases
                            item.setBackground(QColor('#f5f5f5'))
                            item.setToolTip("Complex or missing ID")
                    
                    self.search_results_table.setItem(i, j, item)
            
            # Show completion message
            if len(rows) == 0:
                show_info_message(self, "Search Complete", "No records found matching the search criteria.")
            else:
                # Auto-resize columns
                self.search_results_table.resizeColumnsToContents()
                show_info_message(self, "Search Complete", 
                    f"Found {len(rows)} matching records.\n\n"
                    f"- Double-click rows for details\n"
                    f"- Right-click for context menu\n"
                    f"- Use 'Export Results' to save data")
            
        except Exception as e:
            show_error_message(self, "Search Error", f"Error executing search: {str(e)}")
            print(f"Advanced search error: {e}")  # Debug info

    def setup_batch_operations(self):
        """Setup batch operations for multiple records"""
        try:
            # Add batch operations to rollback tab
            if hasattr(self, 'tab_widget'):
                # Find rollback tab and add batch section
                for i in range(self.tab_widget.count()):
                    if self.tab_widget.tabText(i) == "Rollback":
                        rollback_tab = self.tab_widget.widget(i)
                        if rollback_tab.layout():
                            
                            # Batch operations group
                            batch_group = QGroupBox("Batch Operations")
                            batch_layout = QVBoxLayout()
                            
                            # Batch rollback by time range
                            time_range_layout = QHBoxLayout()
                            time_range_layout.addWidget(QLabel("Rollback all changes from:"))
                            
                            self.batch_from_time = QDateTimeEdit()
                            self.batch_from_time.setDateTime(datetime.now() - timedelta(hours=1))
                            time_range_layout.addWidget(self.batch_from_time)
                            
                            time_range_layout.addWidget(QLabel("to:"))
                            
                            self.batch_to_time = QDateTimeEdit()
                            self.batch_to_time.setDateTime(datetime.now())
                            time_range_layout.addWidget(self.batch_to_time)
                            
                            self.execute_batch_rollback_btn = QPushButton("Execute Batch Rollback")
                            self.execute_batch_rollback_btn.clicked.connect(self.execute_batch_rollback)
                            time_range_layout.addWidget(self.execute_batch_rollback_btn)
                            
                            batch_layout.addLayout(time_range_layout)
                            
                            # Batch results
                            self.batch_results = QTextEdit()
                            self.batch_results.setMaximumHeight(100)
                            self.batch_results.setReadOnly(True)
                            batch_layout.addWidget(self.batch_results)
                            
                            batch_group.setLayout(batch_layout)
                            rollback_tab.layout().addWidget(batch_group)
                            break
                            
        except Exception as e:
            print(f"Error setting up batch operations: {e}")

    def execute_batch_rollback(self):
        """Execute batch rollback for time range"""
        try:
            from_time = self.batch_from_time.dateTime().toPython()
            to_time = self.batch_to_time.dateTime().toPython()
            
            # Confirm operation
            reply = show_question(
                self,
                "Confirm Batch Rollback",
                f"This will rollback ALL changes between:\n"
                f"From: {format_timestamp(from_time)}\n"
                f"To: {format_timestamp(to_time)}\n\n"
                f"This operation affects multiple tables and records!\n"
                f"Continue?"
            )
            
            if reply != QMessageBox.Yes:
                return
                
            # Get affected records
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT DISTINCT schemaname, tabname, COUNT(*)
                FROM {AUDIT_SCHEMA}.t_history
                WHERE tstamp BETWEEN %s AND %s
                GROUP BY schemaname, tabname
                ORDER BY schemaname, tabname
            """, (from_time, to_time))
            
            affected_tables = cursor.fetchall()
            
            success_count = 0
            error_count = 0
            
            self.batch_results.clear()
            self.batch_results.append("Starting batch rollback...\n")
            
            for schema, table, count in affected_tables:
                try:
                    # For each table, rollback to state before from_time
                    cursor.execute(f"""
                        SELECT version_number 
                        FROM {AUDIT_SCHEMA}.t_history
                        WHERE schemaname = %s AND tabname = %s
                        AND tstamp < %s
                        ORDER BY tstamp DESC
                        LIMIT 1
                    """, (schema, table, from_time))
                    
                    result = cursor.fetchone()
                    if result:
                        target_version = result[0]
                        
                        # Execute rollback for this table
                        cursor.execute(f"""
                            SELECT {AUDIT_SCHEMA}.rollback_record_to_version(%s, %s, %s, %s)
                        """, (schema, table, target_version, f"Batch rollback from {format_timestamp(from_time)} to {format_timestamp(to_time)}"))
                        
                        self.batch_results.append(f"✓ {schema}.{table}: {count} changes rolled back")
                        success_count += 1
                    else:
                        self.batch_results.append(f"⚠ {schema}.{table}: No version found before target time")
                        
                except Exception as e:
                    self.batch_results.append(f"✗ {schema}.{table}: Error - {str(e)}")
                    error_count += 1
                    
            self.db_connection.commit()
            cursor.close()
            
            self.batch_results.append(f"\nBatch rollback completed!")
            self.batch_results.append(f"Success: {success_count} tables")
            self.batch_results.append(f"Errors: {error_count} tables")
            
            # Refresh data
            self.load_rollback_history()
            self.load_recent_changes()
            
        except Exception as e:
            self.db_connection.rollback()
            self.batch_results.append(f"Batch rollback failed: {str(e)}")
            show_error_message(self, "Batch Rollback Error", f"Error in batch rollback: {str(e)}")

    def load_hourly_activity_stats(self):
        """Load hourly activity statistics"""
        try:
            if not self.db_connection or self.db_connection.closed:
                return
                
            cursor = self.db_connection.cursor()
            cursor.execute(f"""
                SELECT 
                    EXTRACT(HOUR FROM tstamp) as hour,
                    COUNT(*) as changes
                FROM {AUDIT_SCHEMA}.t_history 
                WHERE tstamp >= CURRENT_DATE - INTERVAL '7 days'
                GROUP BY EXTRACT(HOUR FROM tstamp)
                ORDER BY hour
            """)
            
            hourly_data = cursor.fetchall()
            
            if hasattr(self, 'hourly_activity_table'):
                self.hourly_activity_table.setRowCount(len(hourly_data))
                for i, (hour, changes) in enumerate(hourly_data):
                    self.hourly_activity_table.setItem(i, 0, QTableWidgetItem(f"{int(hour):02d}:00"))
                    self.hourly_activity_table.setItem(i, 1, QTableWidgetItem(str(changes)))
                    
            cursor.close()
            
        except Exception as e:
            print(f"Error loading hourly activity: {e}")

    # =====================================================
    # UI INTERACTION METHODS
    # =====================================================
    
    def filter_recent_changes(self):
        """Apply filters to recent changes"""
        if self.ui_initialized:
            self.load_recent_changes()
        
    def refresh_all_data(self):
        """Refresh all data safely"""
        try:
            if not self.ui_initialized or self.data_loading:
                return
                
            # Use the safe loading methods
            QTimer.singleShot(50, self.safe_load_initial_data)
            
            if hasattr(self, 'status_label'):
                self.status_label.setText("Data refreshed")
        except Exception as e:
            if hasattr(self, 'status_label'):
                self.status_label.setText("Refresh error")
            print(f"Refresh error: {e}")
        
    def toggle_auto_refresh(self, enabled):
        """Enable/disable auto-refresh"""
        try:
            if enabled:
                interval = self.auto_refresh_interval.value() * 1000 if hasattr(self, 'auto_refresh_interval') else DEFAULT_REFRESH_INTERVAL * 1000
                self.auto_refresh_timer.start(interval)
                if hasattr(self, 'status_label'):
                    self.status_label.setText("Auto-refresh active")
            else:
                self.auto_refresh_timer.stop()
                if hasattr(self, 'status_label'):
                    self.status_label.setText("Database connected")
        except Exception as e:
            print(f"Error toggling auto-refresh: {e}")
            
    def show_help(self):
        """Show help dialog"""
        try:
            if not self.help_dialog:
                self.help_dialog = HelpDialog(self)
            self.help_dialog.show()
            self.help_dialog.raise_()
            self.help_dialog.activateWindow()
        except Exception as e:
            show_error_message(self, "Help Error", f"Error opening help: {str(e)}")
            
    def open_audit_setup(self):
        """Open audit system setup dialog"""
        try:
            if self.db_connection and not self.db_connection.closed:
                setup_dialog = AuditSetupDialog(self.db_connection, self)
                setup_dialog.exec_()
            else:
                show_error_message(self, "Connection Error", "No database connection available")
        except Exception as e:
            show_error_message(self, "Setup Error", f"Error opening audit setup: {str(e)}")
            
    def on_cell_double_clicked(self, row, column):
        """Handle double-click to copy Record ID or other cell content"""
        try:
            item = self.recent_changes_table.item(row, column)
            if item:
                text = item.text()
                clipboard = QApplication.clipboard()
                clipboard.setText(text)
                
                # Show notification based on column
                if column == 4:  # Record ID column
                    show_info_message(self, "Copied", f"Record ID '{text}' copied to clipboard!")
                else:
                    show_info_message(self, "Copied", f"Cell content copied to clipboard!")
                    
        except Exception as e:
            print(f"Error copying cell content: {e}")
    
    def show_table_context_menu(self, position):
        """Show enhanced context menu for table"""
        try:
            item = self.recent_changes_table.itemAt(position)
            if item is not None:
                menu = QMenu()
                
                current_row = self.recent_changes_table.currentRow()
                
                # Copy actions
                copy_cell_action = menu.addAction("Copy Cell")
                copy_cell_action.triggered.connect(lambda: self.copy_cell_content(current_row, self.recent_changes_table.currentColumn()))
                
                copy_record_id_action = menu.addAction("Copy Record ID")
                copy_record_id_action.triggered.connect(lambda: self.copy_cell_content(current_row, 4))
                
                menu.addSeparator()
                
                # Enhanced details action
                show_details_action = menu.addAction("Show Full Details")
                show_details_action.triggered.connect(self.show_record_details)
                
                menu.addSeparator()
                
                quick_rollback_action = menu.addAction("Quick Rollback")
                quick_rollback_action.triggered.connect(self.quick_rollback)
                
                menu.addSeparator()
                
                toggle_debug_action = menu.addAction("Toggle Debug Column")
                toggle_debug_action.triggered.connect(self.toggle_debug_column)
                
                menu.exec_(self.recent_changes_table.mapToGlobal(position))
        except Exception as e:
            print(f"Error showing context menu: {e}")
    
    def copy_cell_content(self, row, column):
        """Copy specific cell content to clipboard"""
        try:
            item = self.recent_changes_table.item(row, column)
            if item:
                text = item.text()
                clipboard = QApplication.clipboard()
                clipboard.setText(text)
                
                column_names = ["Date/Time", "User", "Table", "Action", "Record ID", "Reason", "Version", "Debug Keys"]
                column_name = column_names[column] if column < len(column_names) else "Cell"
                
                self.status_label.setText(f"{column_name} copied: {text[:30]}...")
                
        except Exception as e:
            print(f"Error copying cell: {e}")
    
    def show_record_details(self):
        """Show detailed record information"""
        try:
            if not hasattr(self, 'recent_changes_table'):
                return
                
            current_row = self.recent_changes_table.currentRow()
            if current_row < 0:
                show_info_message(self, "No Selection", "Please select a row first.")
                return
                
            # Get record information from table
            timestamp_item = self.recent_changes_table.item(current_row, 0)
            user_item = self.recent_changes_table.item(current_row, 1)
            table_item = self.recent_changes_table.item(current_row, 2)
            action_item = self.recent_changes_table.item(current_row, 3)
            record_id_item = self.recent_changes_table.item(current_row, 4)
            reason_item = self.recent_changes_table.item(current_row, 5)
            
            if not all([timestamp_item, table_item]):
                QMessageBox.warning(self, "Error", "Cannot retrieve record information.")
                return
                
            table_name = table_item.text()
            timestamp_str = timestamp_item.text()
            
            # Parse schema.table
            if '.' in table_name:
                schema, table = table_name.split('.', 1)
            else:
                schema = 'public'
                table = table_name
                
            # Query for full record details using approximate timestamp match
            cursor = self.db_connection.cursor()
            
            # Convert display timestamp back to searchable format
            try:
                # Parse the display format: "DD/MM/YYYY HH:MM:SS"
                parsed_time = datetime.strptime(timestamp_str, "%d/%m/%Y %H:%M:%S")
                search_timestamp = parsed_time.strftime("%Y-%m-%d %H:%M:%S")
            except:
                # Fallback: use the first part of timestamp for searching
                search_timestamp = timestamp_str[:19] if len(timestamp_str) >= 19 else timestamp_str
            
            cursor.execute(f"""
                SELECT 
                    operation,
                    old_val,
                    new_val,
                    change_reason,
                    who,
                    tstamp,
                    version_number
                FROM {AUDIT_SCHEMA}.t_history 
                WHERE schemaname = %s 
                AND tabname = %s
                AND tstamp::text LIKE %s
                ORDER BY tstamp DESC
                LIMIT 1
            """, (schema, table, f"{search_timestamp[:10]}%"))
            
            result = cursor.fetchone()
            cursor.close()
            
            if result:
                self._show_enhanced_record_details_dialog(result, table_name, {
                    'user': user_item.text() if user_item else 'Unknown',
                    'action': action_item.text() if action_item else 'Unknown',
                    'record_id': record_id_item.text() if record_id_item else 'Unknown',
                    'reason': reason_item.text() if reason_item else 'Not specified'
                })
            else:
                QMessageBox.warning(self, "Not Found", 
                    f"Could not find detailed information for this record.\n\n"
                    f"Table: {table_name}\n"
                    f"Timestamp: {timestamp_str}")
            
        except Exception as e:
            show_error_message(self, "Error", f"Error showing record details: {str(e)}")
            print(f"Details error: {e}")  # Debug info
            
    def _show_enhanced_record_details_dialog(self, result, table_name, extra_info):
        """Show enhanced record details in a dialog"""
        operation, old_val, new_val, reason, user, tstamp, version = result
        
        details_dialog = QDialog(self)
        details_dialog.setWindowTitle(f"Record Details - {table_name}")
        details_dialog.setMinimumSize(700, 500)
        
        layout = QVBoxLayout()
        
        # Enhanced basic info
        info_text = f"""<b>Record Information:</b>
Operation: <b>{operation}</b>
User: <b>{user}</b>
Timestamp: <b>{format_timestamp(tstamp)}</b>
Version: <b>{version if version else 'N/A'}</b>
Reason: <i>{reason or 'Not specified'}</i>
Table: <b>{table_name}</b>
Record ID: <b>{extra_info.get('record_id', 'Unknown')}</b>
        """
        
        info_label = QLabel(info_text)
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Tabs for different data views
        data_tabs = QTabWidget()
        
        # JSON data tab
        json_tab = QWidget()
        json_layout = QVBoxLayout()
        
        json_text = QTextEdit()
        json_content = f"""OLD VALUES:
{json.dumps(old_val, indent=2) if old_val else 'None'}

NEW VALUES:
{json.dumps(new_val, indent=2) if new_val else 'None'}"""
        json_text.setPlainText(json_content)
        json_text.setReadOnly(True)
        json_layout.addWidget(json_text)
        json_tab.setLayout(json_layout)
        
        # Field comparison tab (if both old and new exist)
        if old_val and new_val and operation == 'UPDATE':
            compare_tab = QWidget()
            compare_layout = QVBoxLayout()
            
            compare_table = QTableWidget()
            compare_table.setColumnCount(3)
            compare_table.setHorizontalHeaderLabels(["Field", "Old Value", "New Value"])
            
            # Compare fields
            old_dict = old_val if isinstance(old_val, dict) else {}
            new_dict = new_val if isinstance(new_val, dict) else {}
            all_fields = set(old_dict.keys()) | set(new_dict.keys())
            
            changed_fields = []
            for field in sorted(all_fields):
                old_value = old_dict.get(field, '')
                new_value = new_dict.get(field, '')
                if old_value != new_value:
                    changed_fields.append((field, str(old_value), str(new_value)))
            
            compare_table.setRowCount(len(changed_fields))
            for i, (field, old_val_str, new_val_str) in enumerate(changed_fields):
                compare_table.setItem(i, 0, QTableWidgetItem(field))
                
                old_item = QTableWidgetItem(old_val_str)
                old_item.setBackground(QColor('#ffebee'))  # Light red
                compare_table.setItem(i, 1, old_item)
                
                new_item = QTableWidgetItem(new_val_str)
                new_item.setBackground(QColor('#e8f5e8'))  # Light green
                compare_table.setItem(i, 2, new_item)
            
            compare_table.resizeColumnsToContents()
            compare_layout.addWidget(compare_table)
            compare_tab.setLayout(compare_layout)
            
            data_tabs.addTab(compare_tab, f"Changes ({len(changed_fields)})")
        
        data_tabs.addTab(json_tab, "Raw JSON")
        layout.addWidget(data_tabs)
        
        # Action buttons
        button_layout = QHBoxLayout()
        
        copy_json_btn = QPushButton("Copy JSON")
        copy_json_btn.clicked.connect(lambda: self._copy_to_clipboard(json_content))
        
        copy_record_id_btn = QPushButton("Copy Record ID")
        copy_record_id_btn.clicked.connect(lambda: self._copy_to_clipboard(extra_info.get('record_id', '')))
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(details_dialog.accept)
        
        button_layout.addWidget(copy_json_btn)
        button_layout.addWidget(copy_record_id_btn)
        button_layout.addStretch()
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        details_dialog.setLayout(layout)
        details_dialog.exec_()
        
    def _copy_to_clipboard(self, text):
        """Copy text to clipboard"""
        try:
            clipboard = QApplication.clipboard()
            clipboard.setText(str(text))
            show_info_message(self, "Copied", "Content copied to clipboard!")
        except Exception as e:
            print(f"Error copying to clipboard: {e}")
        
    def quick_rollback(self):
        """Quick rollback from table"""
        try:
            if not hasattr(self, 'recent_changes_table'):
                return
                
            current_row = self.recent_changes_table.currentRow()
            if current_row >= 0:
                reply = show_question(
                    self, 
                    "Confirm Rollback", 
                    "Are you sure you want to rollback this change?"
                )
                if reply == QMessageBox.Yes:
                    show_info_message(self, "Rollback", "Feature in development")
        except Exception as e:
            print(f"Error in quick rollback: {e}")
                
    def toggle_debug_column(self):
        """Toggle visibility of debug column"""
        try:
            if hasattr(self, 'recent_changes_table'):
                is_hidden = self.recent_changes_table.isColumnHidden(7)
                self.recent_changes_table.setColumnHidden(7, not is_hidden)
        except Exception as e:
            print(f"Error toggling debug column: {e}")
                
    def export_changes(self):
        """Export changes to CSV"""
        try:
            if not hasattr(self, 'recent_changes_table'):
                QMessageBox.warning(self, "Error", "No data to export")
                return
                
            # Ask user where to save the file
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save changes report",
                f"audit_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                "CSV Files (*.csv)"
            )
            
            if not file_path:
                return
                
            # Export data
            self._export_table_data(file_path)
            
        except Exception as e:
            show_error_message(self, "Export Error", f"Unable to save file:\n{str(e)}")
            
    def _export_table_data(self, file_path):
        """Export table data to CSV file"""
        table = self.recent_changes_table
        
        # Prepare data for export (exclude debug column)
        headers = []
        for col in range(table.columnCount()):
            if col != 7:  # Skip debug column
                header_item = table.horizontalHeaderItem(col)
                headers.append(header_item.text() if header_item else f"Column {col}")
            
        data = []
        for row in range(table.rowCount()):
            row_data = []
            for col in range(table.columnCount()):
                if col != 7:  # Skip debug column
                    item = table.item(row, col)
                    row_data.append(item.text() if item else "")
            data.append(row_data)
            
        # Write CSV file
        with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile, delimiter=';')  # Use ; for Italian Excel compatibility
            
            # Add report metadata
            metadata = [
                ["# Audit System Manager Report"],
                [f"# Generation date: {format_timestamp(datetime.now())}"],
                [f"# Applied filters: User={self.user_filter.currentText() if hasattr(self, 'user_filter') else 'N/A'}, Schema={self.schema_filter.currentText() if hasattr(self, 'schema_filter') else 'N/A'}, Period={self.time_filter.currentText() if hasattr(self, 'time_filter') else 'N/A'}"],
                [f"# Total records: {len(data)}"],
                [f"# Note: Record ID detection improved - now supports multiple ID field types"],
                []  # Empty row
            ]
            
            for row in metadata:
                writer.writerow(row)
            
            # Write headers and data
            writer.writerow(headers)
            for row in data:
                writer.writerow(row)
                
        show_info_message(
            self, 
            "Export Complete", 
            f"Report saved to:\n{file_path}\n\nRecords exported: {len(data)}\n\n"
            f"Note: Export excludes debug column. Use 'Show Record Details' for full JSON data."
        )
    
    def closeEvent(self, event):
        """Cleanup when dialog is closed"""
        try:
            if self.auto_refresh_timer.isActive():
                self.auto_refresh_timer.stop()
            if hasattr(self, 'real_time_timer') and self.real_time_timer.isActive():
                self.real_time_timer.stop()
            if hasattr(self, 'help_dialog') and self.help_dialog:
                self.help_dialog.close()
            event.accept()
        except Exception as e:
            print(f"Error during cleanup: {e}")
            event.accept()


# =====================================================
# PLUGIN ENTRY POINT
# =====================================================

def classFactory(iface):
    """Load plugin class"""
    return AuditSystemManager(iface)